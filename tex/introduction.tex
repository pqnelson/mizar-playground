\chapter{Group Theory in Mizar}

\section{First-Order Logic in Mizar}

\N{Propositional Logic}
We will briefly review Mizar's syntax for formulas.

\begin{equation}
  \neg\Phi\quad\equiv\quad\mathtt{not}~\Phi
\end{equation}
\begin{equation}
  \Phi\lor\Psi\quad\equiv\quad\Phi~\mathtt{or}~\Psi
\end{equation}
\begin{equation}
  \Phi\land\Psi\quad\equiv\quad\Phi~\mathtt{\&}~\Psi
\end{equation}
\begin{equation}
  \Phi\implies\Psi\quad\equiv\quad\Phi~\mathtt{implies}~\Psi
\end{equation}
\begin{equation}
  \Phi\iff\Psi\quad\equiv\quad\Phi~\mathtt{iff}~\Psi
\end{equation}

\N{Typing Statements as Propositions}
Unique to Mizar is that typing judgements are object language
propositions. When we write ``\texttt{x is natural number}'', that's a
proposition. Type theory would make it a judgement, a proposition
\emph{in the metalanguage}. Mizar makes it a proposition in the
\emph{object} language. That is to say, if $t$ is a term in Mizar and
$\mathcal{T}$ is a Mizar type, then
\begin{equation}
  t~\mathtt{is}~\mathcal{T}
\end{equation}
is a proposition in Mizar.

\N{Quantifiers}
Quantifiers are a bit trickier. We quantify a variable over a type.
\begin{equation}
\forall_{x\esti A}\Phi\quad\equiv\quad\mathtt{for}~x~\mathtt{being}~A~\mathtt{holds}~\Phi
\end{equation}
\begin{equation}
\exists_{x\esti A}\Phi\quad\equiv\quad\mathtt{ex}~x~\mathtt{being}~A~\mathtt{st}~\Phi
\end{equation}
We can also just ``stack'' multiple quantifiers next to each other, like
\begin{equation}
\forall_{x\esti A}\forall_{y\esti B}\Phi\quad\equiv\quad\mathtt{for}~x~\mathtt{being}~A~\mathtt{for}~y~\mathtt{being}~B~\mathtt{holds}~\Phi.
\end{equation}
We have syntactic sugar for universal quantification of an implication:
\begin{equation}
\forall_{x\esti A}\Phi\implies\Psi\quad\equiv\quad\mathtt{for}~x~\mathtt{being}~A~\mathtt{st}~\Phi~\mathtt{holds}~\Psi.
\end{equation}

\begin{exercise}
  Translate into Mizar ``Every element $x\in X$ corresponds to a unique
  $y\in Y$ such that $\Phi$ holds.''
\end{exercise}

\N{Referring to Labels}\label{par:introduction:referring-to-labels}
Mizar can refer to theorems from another article, say
``\verb#ARTICLE#'', by writing ``\verb#ARTICLE:56#'' to refer to theorem 56.
Definitions are referred to using ``\verb#ARTICLE:def xx#'' (where
``\verb#xx#'' is a number). \emph{It is a common beginner's mistake to
try to refer to theorem $X$ by writing } ``\verb#ARTICLE:ThX#''.

\N{Final remark on notations used in Mizar}
There are a few quirky choices of notation which I wish to discuss, just
to let the reader be aware of it. I will also remind the reader when it
comes up in the future:\footnote{Shinshu University has a webpage giving
a ``rosetta stone'' for Mizar notation and the usual mathematical
notation, see: \url{http://markun.cs.shinshu-u.ac.jp/kiso/projects/proofchecker/mizar/mizardictionary1.htm}}

\begin{enumerate}
\item\index{\texttt{f.x}!Mizar for $f(x)$} In mathematics, function application is written $f(x)$, but in
  Mizar it is ``\texttt{f.x}''
\item\index{\texttt{f.:A}!Mizar for $f(A)$} Applying a function to a set is denoted $f(A)$, but in Mizar it is
  denoted ``\texttt{f.:A}''
\item\index{\texttt{f''}@{\texttt{f"\""}}!Mizar for $f^{-1}$} The inverse function relating $y=f(x)$ to $f^{-1}(y)=x$, in Mizar
  is denoted by ``\texttt{f".y}''. More generally, instead of using
  superscript $-1$, Mizar will use double quotes.
\item\index{\texttt{f \mid A}@{\texttt{f"|"A}}!Mizar for $f\vert_{A}$} If $f\colon X\to Y$ is a function of sets, and $A\subset X$, then
  we write the restriction of $f$ to $A$ as $f|_{A}\colon A\to X$
  defined by $\forall a\in A, f(a)=f|_{A}(a)$. In Mizar, this
  restriction is denoted ``\verb#f|A#'' and function application with it
  is ``\verb#(f|A).x#'' for $f|_{A}(x)$.
\item\index{\texttt{h in H}!Mizar for $h\in H$} Set membership $x\in X$ is
  denoted in Mizar by the formula ``\verb#x in X#''.
\end{enumerate}

\section{Natural Deduction in Mizar}

\M
Arguably, Mizar consists of three domain specific languages: one for
proofs, another for definitions, and a third for stating formulas. We
have summarized Mizar's syntax for formulas. Let us now consider how
Mizar handles proofs. We basically follow Grabowski and
friends~\cite{grabowski2010mizar} in presenting ``proof skeletons'' to
summarize the semantics of the various proof steps, and
Wiedijk~\cite{wiedijk2000mv} in relating the Mizar proof steps to
natural deduction rules of inference.

Remember, in natural deduction for logic, the basic judgements we're
working with are sequents of the form $\Gamma\vdash\Phi$ where $\Gamma$
is a (possibly empty) list of formulas, and $\Phi$ is proven from
them. We have inference rules, which look like fractions, describing how
to transform such judgements. Inference rules should be read ``from
bottom to top''.

\N{Assume: $\Longrightarrow$-introduction}\index{Assume@\texttt{assume}}
When we want to prove a formula of the form $\Psi\implies\Phi$, we begin
with stipulating $\Psi$ holds. That is to say, we ``\verb#assume# $\Psi$''.
In Mizar:

\begin{mizar}
Psi implies Phi
proof
  :: preliminatry steps
  assume Psi;
  :: proof of Phi
end;
\end{mizar}
This corresponds to the natural deduction rule of inference for
$\Longrightarrow$-introduction:
\begin{equation}
  \infer[\mathtt{assume}~\Psi]{\Gamma\vdash\Psi\implies\Phi}{\Gamma,\Psi\vdash\Phi}.
\end{equation}
Remember, we read this from bottom to top, so if we want to prove
the claim $\Psi\implies\Phi$ (having established the results $\Gamma$),
then the statement ``\verb#assume# $\Psi$'' transforms our proof
obligation to $\Gamma,\Psi\vdash\Phi$ (i.e., proving $\Phi$ from the
list $\Gamma$ with $\Psi$ appended to $\Gamma$).

\N{Assume: proof by contradiction}
Sometimes we want to prove a claim by showing its negation leads to
calamity. This is done routinely in mathematics, since $\neg\Phi$ is
logically equivalent to $\Phi\implies\contradiction$, so double negation
would be equivalent to $\Phi$, right? Right! We have the tautology
$\Phi\iff(\neg\Phi\implies\contradiction)$.

\begin{mizar}
not Psi implies contradiction
proof
  :: preliminatry steps
  assume not Psi;
  :: proof leading to contradiction
end;
\end{mizar}

\N{Assume: proving disjunction}\index{Idiom!Proving $\Phi\lor\Psi$}
The idiomatic way to prove the claim $\Phi\lor\Psi$ in Mizar is to
assume the negation of one of the disjuncts (usually the first, i.e.,
to ``\verb#assume# $\neg\Phi$'') and then prove $\Psi$ holds.
\begin{mizar}
Phi or Psi
proof
  assume not Phi;
  :: proof of Psi
  thus Psi;
end;
\end{mizar}

\begin{ddanger}
  The reader may wonder if they may instead start the proof with
  ``\verb#assume not Psi#'', since that's \emph{logically equivalent}, right?
  The Mizar prover translates formulas and proof steps into a normal
  form (called ``semantic correlates''\index{Semantic Correlate}).
  Unfortunately, starting with ``\verb#assume not Psi#'' translates into
  a \emph{different} semantic correlate. One would have to change the
  claim to ``\verb#Psi or Phi#''.
\end{ddanger}

\N{Thus: $\land$-introduction}\index{Thus@\texttt{thus}}
Whenever we want to prove a claim $\Phi$, we conclude the proof with
``\texttt{thus} $\Phi$''. In Mizar, this looks like (with the
preliminary steps omitted with a comment ``\verb#:: proof of ...#''):

\begin{mizar}
Phi
proof
  :: proof of Phi
  thus Phi;
end;
\end{mizar}

For proving \emph{multiple} claims (i.e., a conjunction), the proof
looks like:

\begin{mizar}
Phi & Psi
proof
  :: proof of Phi
  thus Phi by ...;
  :: proof of Psi
  thus Psi by...;
end;
\end{mizar}
There is some justification for stating ``\verb#thus# $\Phi$'' or
``\verb#thus# $\Psi$'', which are the ``\verb#by ...#'' suffix to the
statements (referring to labels~\S\ref{par:introduction:referring-to-labels}).

This corresponds to the $\land$-introduction rule in natural deduction:
\begin{equation}
  \infer[\mathtt{thus}~\Phi]{\Gamma\vdash\Phi\land\Psi}{
    \Gamma\vdash\Phi &\qquad \Gamma\vdash\Psi}
\end{equation}
where $\Gamma\vdash\Psi$ is the justification for ``\verb#thus# $\Psi$'',
and $\Gamma\vdash\Phi$ is the justification for ``\verb#thus# $\Phi$''.

\begin{remark}[Mizar idiom]\index{Thesis@\texttt{thesis}}\index{Idiom!\texttt{thus thesis}}
Some Mizar code adheres to the idiom of concluding proofs, all proofs,
with the statement ``\verb#thus thesis#''. Here ``\verb#thesis#'' is the
special formula representing what remains to be proven.
\end{remark}

\begin{exercise}[Proving ``if and only if'' claims]
Frequently we have logical equivalences $\Phi\iff\Psi$, how would we
prove it in Mizar? Well, recall, by definition this is
$(\Phi\implies\Psi)\land(\Phi\impliedby\Psi)$.
\end{exercise}

\N{Let: $\forall$-introduction}\index{Let@\texttt{let}}
The most common proof step which starts nearly every proof, introducing
variables.

\begin{mizar}
for a being T holds Phi
proof
  let a be T;
  :: proof of Phi
  thus Phi;
end;
\end{mizar}

This corresponds to the inference rule
\begin{equation}
\infer[\mathtt{let}~y]{\Gamma,y\vdash P(y)}{\Gamma\vdash\forall x,P(x)}
\end{equation}

\N{Consider: $\exists$-elimination}\index{Consider@\texttt{consider}}
When we want to apply the fact $\exists x,\Psi(x)$, we introduce a
``fresh'' variable which satisfies the given condition. In Mizar, this
proof skeleton looks like
\begin{mizar}
Phi
proof
  :: preliminary steps
  consider x such that Psi by ...;
  :: proof of Phi involving x
  thus Phi by ...;
end;
\end{mizar}
This corresponds to the inference rule:
\begin{equation}
\infer[\mathtt{consider}~x~\mathtt{such~that}~\Psi(x)]{\Gamma\vdash\Phi}{%
  \Gamma\vdash\exists x,\Psi(x)
  &\qquad\Gamma,x,\Psi(x)\vdash\Phi}
\end{equation}
The justification for this step refers to the derivation of the upper
left subgoal.

\N{Take: $\exists$-introduction}\index{Take@\texttt{take}}
If we want to prove the claim ``$\exists x,\Phi(x)$'', then we need to
``\verb#take# $t$'' (where $t$ is a term). We can take an explicit term,
like ``\verb#take# $t = f(x)$''. The proof skeleton looks like:
\begin{mizar}
ex t being T st Phi
proof
  :: preliminary steps
  take t;
  :: proof of Phi
  thus Phi;
end;
\end{mizar}
This corresponds to the natural deduction rule of inference:
\begin{equation}
  \infer[\mathtt{take}~t]{\Gamma\vdash\exists x,\Phi(x)}{\Gamma\vdash P(t)}.
\end{equation}

\N{Per cases: $\lor$-elimination}\index{Per Cases@\texttt{per cases}}\index{Suppose@\texttt{suppose}}
When we want to prove $\Psi_{1}\lor\dots\lor\Psi_{n}\implies \Phi$,
we simply prove $\Psi_{1}\implies\Phi$, \dots, $\Psi_{n}\implies\Phi$.
But instead of using the ``\verb#assume#'' step for each of these
proofs, we use the special ``\verb#suppose#'' step to introduce a
subproof.
\begin{mizar}
Phi
proof
  :: preliminary steps
  per cases by ...;
  suppose Psi_1:
    :: proof of Phi from Psi_1
    thus Phi by ...;
  :: suppose Psi_2, ..., Psi_(n-1)
  suppose Psi_n:
    :: proof of Phi from Psi_n
    thus Phi by ...;
end;
\end{mizar}
This corresponds to the natural deduction rule
\begin{equation}
  \infer[\mathtt{per~cases}]{\Gamma\vdash \Phi}{%
    \Gamma\vdash\Psi_{1}\lor\dots\lor\Psi_{n}
    & \qquad\Gamma,\Psi_{1}\vdash\Phi
    & \dots
    & \Gamma,\Psi_{n}\vdash\Phi}
\end{equation}
Here the justification cited in the ``\verb#per cases by...#'' is the
label for the upper-left inference, that $\Gamma\vdash\Psi_{1}\lor\dots\lor\Psi_{n}$.
Each ``\verb#suppose# $\Psi_{j}$; \dots; \verb#thus# $\Phi$'' block
corresponds to the derivation $\Gamma,\Psi_{j}\vdash\Phi$.

\N{Justification, nested subproofs}\index{By@\texttt{by}}\index{Proof!Nested}
I have been trying to include ``\verb#by ...#'' explicitly in proof
steps to reflect which steps require justification. This can be done in
one of two ways:
\begin{enumerate}
\item cite theorems, definitions, and/or labeled steps which occur in
  the proof (as discussed in~\S\ref{par:introduction:referring-to-labels}); or
\item have a subproof, i.e., instead of writing ``\verb#by ...#'', we
  could have a proof on the next line.
\end{enumerate}
There is also syntactic sugar, if one wishes to cite \emph{the previous step},
simply prepend the step with ``\verb#then ...#''. So instead of
\begin{mizar}
proof
  :: A1,A2 omitted but exist
  assume A3: Psi;
  consider x such that Phi by A1,A2,A3;
  :: ...
end;
\end{mizar}
We could equivalently write:
\begin{mizar}
proof
  :: ....
  assume Psi;
  then consider x such that Phi by A2,A3;
  :: ...
end;
\end{mizar}
The two are equivalent.

\begin{ddanger}
  There are two caveats to this rule of prepending ``\verb#then#'' to
  statements: (1) the step ``\verb#then thus# $\Phi$'' looks awkward, so
  Mizar has this be ``\verb#hence# $\Phi$''\index{Hence@\texttt{hence}};
  (2) if we have two statements
  ``\verb#assume ex x st Phi;# \verb#then consider x such that Phi;#'' is
  contracted into a single step
  ``\verb#given x such that Phi;#''\index{Given@\texttt{given}} since
  that resembles working mathematics.
\end{ddanger}

\section{Basic Definitions}

\M We will review the definitions germane to group theory, as inspired
by Nakasho and friends~\cite{nakasho2014formalization}. This entire
section is inspired by their paper.

Recall, as Baez~\cite[week one]{baez2004qg-lectures} notes, there are
two ways to define a group. These two different definitions give rise to
\emph{different} notions of ``group homomorphism'' (but identical
notions of ``group isomorphism''). I will make bold the differences:

\begin{definition}[Version 1]\label{defn:introduction:mizar-style-group}
  A \emph{group} consists of
  \begin{enumerate}
  \item a set $G$
  \end{enumerate}
  equipped with
  \begin{enumerate}
  \item a binary operator $\mu\colon G\times G\to G$
  \end{enumerate}
  such that
  \begin{enumerate}
  \item Associativity: for any $g_{1}$, $g_{2}$, $g_{3}\in G$, we have
    $\mu(g_{1}, \mu(g_{2},g_{3})) = \mu(\mu(g_{1},g_{2}),g_{3})$
  \item \textbf{Existence of Unit: there exists an element $1\in G$ such
    that for any $g\in G$ we have $\mu(g,1)=\mu(1,g)=g$}
  \item \textbf{Existence of inverses: for each $g\in G$, there is an
    $h\in G$ such that $\mu(g,h)=1$}
  \end{enumerate}
\end{definition}

\begin{definition}[Version 2]
  A \emph{group} consists of
  \begin{enumerate}
  \item a set $G$
  \end{enumerate}
  equipped with
  \begin{enumerate}
  \item a binary operator $\mu\colon G\times G\to G$
  \item \textbf{a unit $1\in G$}
  \item \textbf{an inverse operator $\iota\colon G\to G$}
  \end{enumerate}
  such that
  \begin{enumerate}
  \item Associativity: for any $g_{1}$, $g_{2}$, $g_{3}\in G$, we have
    $\mu(g_{1}, \mu(g_{2},g_{3})) = \mu(\mu(g_{1},g_{2}),g_{3})$
  \item \textbf{Unit laws: for any $g\in G$ we have $\mu(g,1)=\mu(1,g)=g$}
  \item \textbf{Inverse law: for each $g\in G$, $\mu(\iota(g),g)=1$}
  \end{enumerate}
\end{definition}

\begin{remark}
I will adopt modern terminology, and simply refer to a group
homomorphism as a ``\emph{group morphism}'', or more tersely as just a
morphism.
\end{remark}

\M\index{Magma|(} Mizar takes the first version as its definition. Implicit in its
definition is a notion of a ``\verb#multMagma#'', a magma with a
multiplication operator (defined in \verb#ALGSTR_0#). As Nakasho and
friends explicate~\cite{nakasho2014formalization}, a ``\verb#multMagma#''
is a magma as could be found in, e.g., Bourbaki's\index{Bourbaki, Nicholas}
\emph{Algebra}~\cite[see Ch.I\S1.1]{bourbaki1974elements}: it
consists of a set (which Mizar calls its ``\verb#carrier#'') and a
binary operator ``\verb#multF#''.\index{multF@\texttt{multF}}\index{carrier@\texttt{carrier}}\index{multMagma@\texttt{multMagma}}

Note: comments in Mizar are started by ``\verb#::#'' and continue until
the end of the line.

\begin{mizar}
:: algstr_0.miz
definition
  struct (1-sorted) multMagma (# carrier -> set,
  multF -> BinOp of the carrier
  #);
end;
\end{mizar}

\M
Let us unpack what is going on in this code. We are defining a
\verb#struct#,\index{Struct@\texttt{struct}} a mathematical structure which is usually presented in
ordinary mathematics as a tuple of some kind $\langle\dots\rangle$. For
example, a field might be presented as $\langle F, +, \cdot, 0, 1\rangle$
consisting of a set $F$, a couple binary operators, and a couple of
selected elements of $F$.

Mizar's grammar for defining a structure is:
\begin{equation}
  \langle\textit{structure-definition}\rangle ::=
  \mbox{\texttt{struct}}~(\langle\textit{ancestors}\rangle)~\langle\textit{symbol}\rangle~
  \mbox{\texttt{(\#}}\quad
  \langle\textit{fields}\rangle\quad
  \mbox{\texttt{\#)}}
  \texttt{;}
\end{equation}
The ancestors are optional. For ``\verb#multMagma#'',\index{multMagma@\texttt{multMagma}} it has one ancestor
(namely, ``\verb#1-sorted#''\index{1-sorted@\texttt{1-sorted}}). The fields for a structure look like a
comma-separated list whose entries are of the form:
\begin{equation}
  \langle\textit{field}\rangle ::= \langle\textit{identifier}\rangle\quad\mbox{\texttt{->}}\quad\langle\textit{type}\rangle
\end{equation}
We see that ``\texttt{multMagma}'' has two fields:
\begin{enumerate}
\item ``\texttt{carrier}'' which is a set
\item ``\texttt{multF}'' which is a ``\texttt{BinOp}'' (binary operator)
  acting on the ``\texttt{carrier}''.
\end{enumerate}
This matches Bourbaki's definition of a magma.\index{Magma|)}

\begin{remark}[Accessing fields of a structure]
We can refer to, e.g., the ``\verb#multF#'' of a given instance of a
``\verb#multMagma#'' by writing
``\verb#the multF of <instance>#''. These are called accessor
functors. Sometimes we want to access ``the underlying magma'' of an
algebraic gadget, and a horrible pun used to describe this is the
\emph{forgetful functor}\index{Functor!Forgetful}. We discuss more about
functors later on (\S\ref{par:introduction:functor-one-g}).
\end{remark}

\begin{remark}[Multiplication operator]\label{rmk:introduction:multiplication-operator}\index{\texttt{x * y}}
Before continuing on too far, I should note that for a
``\texttt{M being multMagma}'' we have an infix binary operator
``\texttt{x*y = (the multF of M).(x,y)}''. This is defined in
\verb#ALGSTR_0:def 19#.\MizDef{ALGSTR\_0}{19}
\end{remark}

\N{Equality of Instances of Structures}
If we a structure $\mathtt{Foo} \langle \mathsf{F}_{1},\dots,\mathsf{F}_{n}\rangle$
with $n$ fields $\mathsf{F}_{j}$, then we can make an instance of it
using notation ``\verb$Foo(# F1, ..., Fn #)$''. Equality of two
instances follows the same axiomatic behavior as ordered $n$-tuples:
\verb$Foo(# E1, ..., En #) = Foo(# F1, ..., Fn #)$ if and only if
\verb#E1# = \verb#F1# and \dots and \verb#En# = \verb#Fn#. If we tried
to assert two \emph{different} structures are equal --- e.g.,
\verb$Foo(# E1, ..., En #) = Bar(# F1, ..., Fm #)$ --- well, this is not
allowed, Mizar will reject it.

One caveat to this is if we have, for example, a topological group
$G_{1}$ (which has all the fields as a group \emph{and} a topological
space \emph{combined}) and, say, $S_{n}$ (which has all the fields of a
group, but nothing else), then we cannot meaningfully compare these
two. We will need to do something like write ``\verb#the Group of G1 = Sn#''
to compare the \emph{group structure} of $G_{1}$ to the \emph{Group structure}
of $S_{n}$.

\N{Mizar's definition of Group}
Mizar formalizes a group following the style of
Definition~\ref{defn:introduction:mizar-style-group}: it's a magma which
satisfies a bunch of extra properties (as opposed to a magma equipped
with more structure). Mizar's notion of ``extra properties'' is handled
by a mechanism called \define{Attributes}\index{Attribute!Mizar}, which
are adjectives we can tack onto types and they encode certain axioms or
formulas which must hold. There are three such attributes being defined
immediately in \texttt{group\_1.miz}:
\begin{enumerate}
\item ``\texttt{unital}''\index{unital@\texttt{unital}} which asserts
  $\exists_{e\esti \mathtt{IT}}\forall_{h\esti \mathtt{IT}} \mu(h,e)=h\land\mu(e,h)=h$
\item ``\texttt{Group-like}''\index{Group-like@\texttt{Group-like}},
  which extends the condition of ``\texttt{unital}'' with the assertion
  that for any element $h$ and inverse element $g$ exists
  $\exists_{e\esti \mathtt{IT}}\forall_{h\esti \mathtt{IT}} \mu(h,e)=h\land\mu(e,h)=h\land\exists_{g\esti \mathtt{IT}}\mu(h,g)=e\land\mu(g,h)=e$
\item ``\texttt{associative}''\index{associative@\texttt{associative}}
  which corresponds to our demand of associativity
  $\forall_{x,y,z\esti \mathtt{IT}}\mu(\mu(x,y),z)=\mu(x,\mu(y,z))$.
\end{enumerate}
With these attributes in hand, Mizar defines a group to be a
``\texttt{Group-like associative non empty multMagma}'', i.e., a magma such
that it is associative and group-like (has an identity element and for
each element, a corresponding inverse element exists). This is collected
in a new type, or \define{Mode}\index{Mode!in Mizar} (as Mizar calls them).

\index{Unital@\texttt{unital}|(}\index{Group-like@\texttt{Group-like}|(}\index{Associative@\texttt{associative}|(}
\begin{mizar}
:: group_1.miz
definition
  let IT be multMagma;

  attr IT is unital means
:: GROUP_1:def 1
  ex e being Element of IT st for h being
  Element of IT holds h * e = h & e * h = h;

  attr IT is Group-like means
:: GROUP_1:def 2
  ex e being Element of IT st for h being Element of IT
  holds h * e = h & e * h = h &
        ex g being Element of IT st h * g = e & g * h = e;

  attr IT is associative means
:: GROUP_1:def 3
  for x,y,z being Element of IT holds (x*y )*z = x*(y*z);
end;

definition
  mode Group is Group-like associative non empty multMagma;
end;
\end{mizar}
\index{Associative@\texttt{associative}|)}\index{Group-like@\texttt{Group-like}|)}\index{Unital@\texttt{unital}|)}\index{Group@\texttt{Group}|textbf}

\begin{remark}[Mizar Idiom]\label{rmk:introduction:idiom-it-in-attributes}\index{Idiom!IT in Attributes}
Whenever defining an attribute in Mizar, we have an ambient
``\verb#IT#'' object for which the attribute will be defined upon. For
example, these attributes appearing in \verb#GROUP_1:def 1# are defined
on a \verb#multMagma#.
\end{remark}

\begin{remark}[Registering attributes]\index{Registration}
Once we have defined attributes, we cannot use them as adjectives for
types until we ``\verb#register#'' them. Without registration, writing
something like ``\texttt{let x be associative multMagma}'' would confuse
Mizar, and it would throw an error. Until registered, we would have to
write something like ``\texttt{let x be multMagma; assume x is associative}''
or ``\texttt{let x be multMagma such that x is associative}''.
\end{remark}

\M Observe that a more faithful translation of Mizar's definition would
be:

\begin{quote}
  \textbf{Definition.} A \emph{Group} $\langle G,\cdot\rangle$ is a set of
  elements with a binary operator $\cdot\colon G\times G\to G$
  satisfying the following conditions:
  \begin{enumerate}
  \item \textbf{Associativity:} for all $a,b,c\in G$, we have $(a\cdot b)\cdot c = a\cdot(b\cdot c)$
  \item \textbf{Identity element:} There exists an element $e$ such that
    $e\cdot a= a\cdot e = a$ for all $a\in G$
  \item \textbf{Inverse Element:} For all $a\in G$, there exists an
    element $b\in G$ with $a\cdot b=b\cdot a = e$.
  \end{enumerate}
\end{quote}

We often work with multiple groups, and if we want to refer to the
identity element of a particular group, then in ordinary mathematics we
write either $1_{G}$ (if $G$ uses multiplicative notation) or $0_{G}$
(if $G$ uses addition). Mizar has a way to encode this convention, which
is the next definition in
\texttt{group\_1.miz}:\MizDef{GROUP\_1}[04]{4}
\mizindex{1G@$\mathtt{1\_G}$}

\begin{mizar}
definition
  let G be multMagma such that
A1: G is unital;
  func 1_G -> Element of G means
:: GROUP_1:def 4
  for h being Element of G holds h * it = h & it * h = h;
  existence by A1;
  uniqueness
  proof
    let e1,e2 be Element of G;
    assume that
A2: for h being Element of G holds h * e1 = h & e1 * h = h and
A3: for h being Element of G holds h * e2 = h & e2 * h = h;
    thus e1 = e2 * e1 by A3
           .= e2 by A2;
  end;
end;
\end{mizar}

\N{Functor Definitions}\label{par:introduction:functor-one-g} What's going on here? Well, for any unital magma $G$, we have a
``functor'' (a logical function, i.e., parametrized term) denoted
``\verb#1_#'' which produces the unit element for the given magma.
Whereas (in print) mathematicians would write $1_{G}$, in Mizar we would
write ``\verb#1_G#''.

Such a term is defined as $\forall h\in G, h\cdot\mathtt{it}=h\land\mathtt{it}\cdot{h}=h$.
Here ``\verb#it#''\index{It@\texttt{it}} anaphorically\footnote{We have
Lisp programmers to thank for this lovely term.} refers to the
definiendum (the term being defined, i.e., ``\verb#1_G#''). Whenever
functors are defined, their defining properties will involve
``\verb#it#'' satisfying some formula.\footnote{The ``\texttt{IT}''
appearing in definitions of attributes play an analogous role, hence the
idiom noted in Remark~\ref{rmk:introduction:idiom-it-in-attributes}.}

Mizar demands we prove such a thing exists, and then a proof of
uniqueness is supplied. This coincides with the usual practice in
mathematical logic, when considering a ``function term'' in first-order
logic, which has [existence] exactly one [uniqueness] output for each
possible argument configuration.

\begin{remark}[Functors in Mizar]\index{Functor!In Mizar|(}
A functor in Mizar is the only way to construct a term. Rudnicki and
friends~\cite{rudnicki2001commutative} cite the term originating from
Rasiowa and Sikorski~\cite[see p.148]{rasiowa1963mathematics},
quoting: ``\dots some signs in the formalized language should correspond
to the mappings and functions being examined. These signs are called
\emph{functors}, or---more precisely---\emph{$m$-argument functors}
provided they correspond to $m$-argument mappings from objects to
objects ($m = 1, 2, \dots$)''.

\emph{\textbf{This has absolutely no relation to functors in category theory},
and in my opinion is an extremely poor
choice of terminology due entirely to the ironies of history.}
\index{Functor!In Mizar|)}\end{remark}

\N{Inverse operator for group elements}
When we have a group $\langle G,\cdot\rangle$, we also have the ability
to invert any given element $g\in G$. Mizar denotes this by
``\verb#g"#'', which is what the ``Rosette stone'' of notation suggests
(since mathematicians would write $g^{-1}$). This is handled in
``\verb#GROUP_1:def 5#''.\MizDef{GROUP\_1}[05]{5}
A formal ``\verb#inverse_op(G)#''\mizindex{Inverse Op(G)@$\mathtt{inverse\_op(G)}$} is given in
``\verb#GROUP_1:def 6#''.\MizDef{GROUP\_1}[06]{6}

\begin{remark}[Inverse operator for subsets of $G$]
We generalize this notation in group theory to write, if $A\subset G$ is
some subset, $A^{-1}=\{a^{-1}\in G\mid a\in A\}$. Mizar defines this
notation in \verb#GROUP_2:def 1#.\MizDef{GROUP\_2}[01]{1}
\end{remark}

\N{Power operator}
For any $g\in G$, and $n\in\NN_{0}$, we often write $g^{n}$ with the
understanding this stands for $g^{0}=1_{G}$ and $g^{n+1}=g^{n}\cdot g$.
This is defined in ``\verb#GROUP_1:def 7#''\MizDef{GROUP\_1}[07]{7}. But we generalize this in
mathematics to let $n\in\ZZ$, allowing the case when $n<0$ to be defined
by $g^{n} = (g^{|n|})^{-1}$.

Mizar does this in
``\verb#GROUP_1:def 8#'',\MizDef{GROUP\_1}[08]{8} following the conventions
taken by earlier articles in Mizar that $x^{y}$ is denoted by
``\verb#x |^ y#''.\index{\texttt{x \mid\Caret y}@{\texttt{x "|"\Caret\ y}}!Mizar for $x^{y}$}
For the sake of consistency, Mizar explicitly states in
``\verb#GROUP_1:def 8#'' when $g\in G$ and $n\esti \NN_{0}$, it follows
that ``\verb#g |^ n#'' coincides with what we expect (i.e., $g^{n}$).

\N{Order of Group Element (and Group Order)}
If $h\in G$, then we say $h$ is of order 0 if the only $n\in\NN_{0}$
satisfying $h^{n}=1_{G}$ is $n=0$. Mizar defines this as an attribute in
``\verb#GROUP_1:def 10#''\MizDef{GROUP\_1}{10} as ``\verb#being_of_order_0#''\index{Being of Order 0@$\mathtt{being\_of\_order\_0}$}\mizindex{Being of Order 0@$\mathtt{being\_of\_order\_0}$}.
This segues into defining the notion of the order for an element $g\in G$
as the smallest natural number $|g|=n\in\NN_{0}$ for which $g^{n}=1_{G}$
(provided $g$ is not of order zero, in which case we specially define
its order to be $|g|=0$). Mizar defines this as
``\verb#ord g#''\index{Order!\texttt{ord g}}\mizindex{ord g@$\mathtt{ord~g}$} in ``\verb#GROUP_1:def 11#''.\MizDef{GROUP\_1}{11}

The order of the group, Mizar overloads the cardinality operator (again,
matching mathematical practice). Specifically,
for $G$ being any finite 1-sorted typed object (like a group), we have
``\verb#card G#''\mizindex{Card G@\texttt{card G}}\index{Cardinality@\texttt{card G}} be the cardinality
of the underlying set.

\N{Abelian Groups}
Sadly, Mizar departs from mathematical practice, and defines an
attribute in ``\verb#GROUP_1:def 12#''\MizDef{GROUP\_1}{12} for a \verb#multMagma# to be
``\verb#commutative#''.\index{Commutative@\texttt{commutative}}\index{Abelian|see{\texttt{commutative}}}\mizindex{Commutative@\texttt{commutative}}
This demands the expected property
\begin{equation*}
  \forall x,y\in G, x\cdot y=y\cdot x.
\end{equation*}

\section{Subgroups}

\N{Helper notation}
We have $A,B\subset G$ be subsets of the carrier set underlying a
non-empty magma $G$. Then we can define ``\verb#A*B#'' as the set of
elements of the form $ab$ for $a\in A$ and $b\in B$. This was done in
\verb#GROUP_2:def 2#\MizDef{GROUP\_2}[02]{2}. Similarly (in definitions
3 and 4\MizDef{GROUP\_2}[03]{3}\MizDef{GROUP\_2}[04]{4}) we can define
for any subset $A\subset G$ and any $g\in G$ the product $Ag$ and $gA$
in the obvious way.

For any subgroup $H\subgroup G$ and subset $A\subset G$,
\verb#GROUP_2:def 11#\MizDef{GROUP\_2}{11} defines \verb$A*H$ and
\verb$H*A$ \emph{as subsets of the carrier of $G$} using the set
underlying $H$, then using the earlier definitions (from
\verb#GROUP_2:def 2#).

Similarly, for any subgroup $H\subgroup G$ and $g\in G$, we have
\verb#g*H# and \verb#H*g# be defined using the underlying set of $H$.

\N{Subgroup}
For a group $G$, \verb#GROUP_2:def 5#\MizDef{GROUP\_2}[05]{5} defines a
``\verb#Subgroup of G#'' to be a Group-like non-empty \verb#multMagma#
such that its carrier is a subset of the underlying set of $G$, and the
Subgroup's multiplication operator is the multiplication from $G$
restricted to the Subgroup.

\begin{remark}[Notation]
We denote $H\subgroup G$ for the statement ``$H$ is a subgroup of $G$''.
\end{remark}

\N{Equality of Subgroups}
For reasons which are not well documented, \verb#GROUP_2:def 6#
redefines equality for \emph{strict} Subgroups. Non-strict subgroups
cannot be equal (not as subgroups).

\N{Trivial Subgroups}\index{$\trivialSubgroup_{G}$}
For any group $G$, $\trivialSubgroup_{G}$ is the trivial subgroup
consisting of the identity element \verb#1_G# and nothing else. This is
defined in \verb#GROUP_2:def 7#\MizDef{GROUP\_2}[07]{7} and denoted \verb#(1).G#\mizindex{1.G@$\mathtt{(1).G}$}. The other
trivial subgroup is denoted by mathematicians as $G$ itself, but Mizar
distinguishes this trivial improper subgroup as $\Omega_{G}$\index{$\Omega_{G}$} in
\verb#GROUP_2:def 8#\MizDef{GROUP\_2}[08]{8}.\mizindex{Omega.G@$\mathtt{(Omega).G}$}

\N{Intersection of Subgroups}
If $H_{1}\subgroup G$ and $H_{2}\subgroup G$, then $H_{1}\cap H_{2}$ is
a subgroup of $G$, too. Mizar denotes this by
\texttt{H1 /\char`\\{} H2}\index{\texttt{H1 /\char`\\{} H2}}. Its
defined in \verb#GROUP_2:def 10#\MizDef{GROUP\_2}{10} as the group whose
underlying set is the intersection of the sets underlying $H_{1}$ and $H_{2}$.

\N{Cosets}
For any subgroup $H\subgroup G$, we can consider the left (or right)
cosets of $H$ as the family of subsets of $G$ of the form
$\{gH|g\in G\}$ (resp., $\{Hg|g\in G\}$). This is defined in
\verb#GROUP_2:def 15,16#.\MizDef{GROUP\_2}{15}\MizDef{GROUP\_2}{16}\mizindex{Right Cosets@$\mathtt{Right\_Cosets}$}\mizindex{Left Cosets@$\mathtt{Left\_Cosets}$}

This naturally leads to a notion of the index of a subgroup $H\subgroup G$,
which Mizar defines as \verb#Index H#\mizindex{Index@\texttt{Index}} in \verb#GROUP_2:def 17#\MizDef{GROUP\_2}{17} as the
cardinality of the collection of left cosets of $H$ in $G$. This is
proven to be the same as the same definition using right cosets in
\verb#GROUP_2:Th 145#.\MizThm{GROUP\_2}{145}

More generally, the collection of all possible subgroups of $G$ is given
in \verb#GROUP_3:def 1#\MizDef{GROUP\_3}[01]{1} as
``\verb#Subgroups G#''\mizindex{Subgroups@\texttt{Subgroups}}.

\N{Conjugation}
For any $a,b\in G$ the conjugate of $a$ by $b$ defined as $a^{b}$ (or
using Mizar syntax ``\verb#a |^ b#''\index{\texttt{x \mid\Caret y}@{\texttt{x "|"\Caret\ y}}!Mizar for $x^{y}$}\mizindex{\texttt{x \mid\Caret y}@{\texttt{x "|"\Caret\ y}}})
for $b^{-1}ab$. For subsets $A,B\subset G$, we define
``\verb#A |^ B#'' for $\{g^{h}\mid g\in A,h\in B\}$. We similarly have
$A^{g}$ be defined as $A^{\{g\}}$, and $g^{A}$ is defined as $\{g\}^{A}$.

Analogous definitions hold for subgroups $H\subgroup G$ and $a\in G$, we
have $H^{a}$ be \emph{the strict subgroup} of $G$ whose underlying set
is given by $H^{\{a\}}$.

We have a predicate to assert two elements $a,b\in G$ are
conjugate. Namely, ``\verb#a,b are_conjugated#''\mizindex{Are Conjugated@$\mathtt{are\_conjugated}$} if there exists some
$g\in G$ such that $a = b^{g}$. This is done in
\verb#GROUP_2:def 7#\MizDef{GROUP\_2}[07]{7}. We generalize this
definition to arbitrary subsets $A$, $B\subset G$ \verb#are_conjugated# if
there is a $g\in G$ such that $A = B^{g}$. Similarly, two subgroups
$H_{1}$, $H_{2}\subgroup G$ \verb#are_conjugated# if there is a $g\in G$
such that the magma underlying $H_{1}$ is equal to $H_{2}^{g}$.

The conjugacy class for:
\begin{enumerate}
\item an element $a\in G$ is defined ``in the obvious way''
as ``\texttt{con\_class a}\mizindex{Conjugacy Class@$\mathtt{con\_class}$}
is the subset \verb#a |^ (Omega).G#'';
\item a subset $A\subset G$ as the collection of all subsets $B\subset G$
such that $A$ and $B$ \verb#are_conjugated# (i.e., there is a $g\in G$
such that $A = B^{g}$);
\item a subgroup $H\subgroup G$ as the collection of all subgroups which
  are conjugate to $H$
\end{enumerate}

\N{Normal Subgroups}
Having thus described conjugation of elements, subsets, and subgroups by
elements, subsets, and subgroups, we have enough infrastructure to
define a notion of ``normal subgroup''. Mizar's
\verb#GROUP_2:def 13#\MizDef{GROUP\_2}{13} defines an attribute for a subgroup
$N\subgroup G$ is \verb#normal#\mizindex{Normal@\texttt{normal}} if for
every $a\in G$, we have $N^{a}$ and $N$ \verb#are_conjugated# (more
literally, $N^{a} = \mathtt{the~multMagma~of~}N$).

For any subset $A\subset G$, the \verb#Normalizer#\mizindex{Normalizer@\texttt{Normalizer}} of $A$ is defined in
\verb#GROUP_2:def 14#\MizDef{GROUP\_2}{14} as the subgroup of $G$ whose
underlying set is $\{h \mid A^{h} = A\}$. We generalize this notion in
\verb#GROUP_2:def 15# to subgroups $H\subgroup G$ by just taking the
normalizer of the underlying set of $H$.

\N{Group generated by a subset}
For $A\subset G$, we define\index{$\langle A\rangle$}
\begin{equation}
\langle A\rangle = \bigcap_{A\subset H\subgroup G} H.
\end{equation}
Mizar defines this in \verb#GROUP_3:def 4#\MizDef{GROUP\_3}[04]{4} as
``\verb#gr A#''\mizindex{Gr A@\texttt{gr A}}. In fact, this defining
property of $\langle A\rangle$ is proven in
\verb#GROUP_3:Th34#\MizThm{GROUP\_3}{34}.

\N{Element is Generating}
We call an element $a\in G$ \emph{generating} if there is an $A\subset G$
such that $\langle A\rangle = G$ (i.e., \texttt{gr A = G}) and
$\langle A\setminus\{a\}\rangle\neq G$ (i.e., \texttt{gr(A \ \{a\}) = G}).
Mizar provides this in \verb#GROUP_3:def 5#\MizDef{GROUP\_3}[05]{5} as
an attribute \verb#generating#\mizindex{Generating@\texttt{generating}}.

\N{Frattini Subgroup}\index{Frattini Subgroup}\index{$\Phi(G)$}
We define a maximal subgroup as one which is proper and not contained in
any other proper subgroup (Mizar defines this as an attribute for a
subgroup $H\subgroup G$ in \verb#GROUP_3:def 6#\MizDef{GROUP\_3}[06]{6}\mizindex{Mazimal@\texttt{maximal}}).
This is necessary to define the Frattini subgroup $\Phi(G)$ as the
intersection of all proper maximal subgroups of $G$ when $G$ is finite
and nontrivial (when $G=\trivialSubgroup$ or $G$ is infinite, then
$\Phi(G)=G$). Mizar uses this very definition in
\verb#GROUP_3:def 7#\MizDef{GROUP\_3}[07]{7} to define \texttt{Phi(G)}\mizindex{Phi(G)@\texttt{Phi(G)}}
as a functor.

Coincidentally, this is a characteristic subgroup of $G$.
% Encyclopedia of mathematics cites the following for further results
% concerning Phi(G):
% [a4] D.J.S. Robinson, "A course in the theory of groups" , Springer (1982)
% [a5] W.R. Scott, "Group theory" , Prentice-Hall (1964)
