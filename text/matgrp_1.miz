:: Matrix Groups
::  by Alexander M. Nelson
::
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies TARSKI, NAT_1, VECTSP_1, SUBSET_1, MATRIX_1, REWRITE1, RELAT_1,
   MESFUNC1, STRUCT_0, ALGSTR_0, NUMBERS, ARYTM_1, FINSEQ_1, TREES_1, ARYTM_3, SUPINF_2,
   XXREAL_0, CARD_1, QC_LANG1, ZFMISC_1, RELAT_2, FUNCOP_1, GROUP_1,
   MATRIX_6, FUNCSDOM, MATRIX_0, MATGRP_1,
   BINOP_1, FUNCT_1, MONOID_0, XBOOLE_0, FDIFF_1, REALSET1;
   
 constructors XBOOLE_0, NUMBERS, XXREAL_0, :: STRUCT_0,
   ALGSTR_0, FVSUM_1,
   MATRIX_4, MATRIX_1,
   VECTSP_1,
   RELSET_1, FUNCT_1, FUNCT_2, FUNCT_5, REALSET1, BINOP_1, MONOID_0, GROUP_1,
   MATRIX_3,  MATRIX_6, STRUCT_0, SUBSET_1;
   
 notations TARSKI, XBOOLE_0, ZFMISC_1, ORDINAL1, NUMBERS, FINSEQ_1,
   RLVECT_1, GROUP_1, VECTSP_1, MATRIX_0, MATRIX_1,
   MATRIX_4, XXREAL_0, SUBSET_1, :: STRUCT_0,
   RELSET_1, FUNCT_1, FUNCT_2, FUNCT_5, REALSET1, BINOP_1, MONOID_0,
   MATRIX_3, MATRIX_6, STRUCT_0, ALGSTR_0;

 registrations XBOOLE_0, SUBSET_1, STRUCT_0, ALGSTR_0, GROUP_1, GROUP_2, MONOID_0,
   RELAT_1, FUNCT_1, PARTFUN1, REALSET1, RELSET_1, FUNCT_2,
   NUMBERS, ORDINAL1, XXREAL_0, XREAL_0, NAT_1, INT_1, NAT_2,
   MEMBERED, VECTSP_1, MATRIX_0, MATRIX_1, MATRIX_6;

 requirements BOOLE, SUBSET, NUMERALS, REAL, ARITHM;

 definitions VECTSP_1, MATRIX_3, ALGSTR_0, STRUCT_0; ::, ALGSTR_0;

 equalities TARSKI, BINOP_1, MATRIX_0, MATRIX_4, ALGSTR_0, STRUCT_0;

 expansions BINOP_1, ALGSTR_0, STRUCT_0;

 theorems ALGSTR_0, ZFMISC_1, RLVECT_1, MATRIX_0, MATRIX_4, MATRIX_3,
   VECTSP_1, NAT_1, SUBSET_1, STRUCT_0, MONOID_0,
   CARD_2, XXREAL_0, MATRIX_1, MATRIX_6, TARSKI,
   FUNCT_1, FUNCT_2, BINOP_1, PARTFUN1,
   GROUP_1, REALSET1;

 schemes BINOP_1, SUBSET_1;

begin :: Monoid of Square Matrices over a Commutative Ring

reserve n for positive Nat;
reserve R for Ring;

definition
  let R be Ring;
  let n be positive Nat;
  let IT be set;
  attr IT is (n,R)-matrix-membered means :Def1:
  for x being object st x in IT holds x is Matrix of n,R;
end;

registration
  let R be Ring;
  let n be positive Nat;
  cluster n-Matrices_over R -> (n, R)-matrix-membered;
  correctness
  proof
    for x being object
    holds x in n-Matrices_over R iff x is Matrix of n,R
    proof
      let x be object;
      x is Element of n-Matrices_over R iff x is Matrix of n,R by MATRIX_1:2;
      hence thesis;
    end;
    hence thesis;
  end;
end;
    
registration
  let R be Ring;
  let n be positive Nat;
  cluster non empty (n,R)-matrix-membered for set;
  existence
  proof
    take n-Matrices_over R;
    thus thesis;
  end;
end;

registration
  let R be Ring;
  let n be positive Nat;
  cluster n-Matrices_over R -> non empty (n, R)-matrix-membered;
  correctness;
end;

definition
  let R be Ring;
  let n be positive Nat;
  let A be non empty (n,R)-matrix-membered set;
  redefine mode Element of A -> Matrix of n,R;
  correctness by Def1;
end;

:: definition
::   let R,n;
::   redefine func n-Matrices_over R equals :DefNewMat:
::   the set of all M where M is Matrix of n, R;
::  :: { A where A is Matrix of n, R : not contradiction };
::   compatibility
::   proof
::     set M = { A where A is Matrix of n, R : not contradiction };
::     for x being set holds x = n-Matrices_over R iff x = M 
::     proof
::       let x be set;
::       for y being object holds y in n-Matrices_over R iff y in M
::       proof
::         let y be object;
::         hereby 
::           assume y in n-Matrices_over R;
::           then y is Matrix of n, R by MATRIX_1:2;
::           hence y in M;
::         end;
::         assume Z2: y in M;
::         then ex Y being Matrix of n,R st y=Y;
::         then y is Matrix of n, R;
::         then y is Element of n-Matrices_over R by MATRIX_1:2;
::         hence y in n-Matrices_over R;
::       end;
::       then A1: n-Matrices_over R = M by TARSKI:2;
::       hereby 
::         assume x = n-Matrices_over R;
::         hence x = M by A1;
::       end;
::       assume x = M;
::       hence x = n-Matrices_over R by A1;
::     end;
::     hence thesis;
::   end;
:: end;

:: definition
::   let R,n;
::   redefine func n-Matrices_over R equals :NewDef:
::   the set of all M where M is Matrix of n, R;
::   correctness;
:: end;

definition
  let R be Ring;
  let n be positive Nat;
  let A be non empty Subset of n-Matrices_over R;
  redefine mode Element of A -> Matrix of n,R;
  correctness
  proof
    thus for x being Element of A holds x is Matrix of n,R by MATRIX_1:2;
  end;
end;

definition
  let R be Ring;
  let n be positive Nat;
  let IT be 1-sorted;
  attr IT is (n,R)-matrix-membered means :Def2:
  the carrier of IT is (n,R)-matrix-membered;
  :: for x being Element of IT holds x is Matrix of n,R;
end;

registration
  let R be Ring;
  let n be positive Nat;
  cluster strict non empty (n,R)-matrix-membered for 1-sorted;
  existence
  proof
    take A = 1-sorted (# n-Matrices_over R #);
    thus A is strict;
    thus A is non empty;
    thus A is (n,R)-matrix-membered;
  end;
end;

registration
  let R be Ring;
  let n be positive Nat;
  let A be non empty (n,R)-matrix-membered 1-sorted;
  cluster the carrier of A -> non empty (n,R)-matrix-membered;
  correctness by Def2;
end;

:: definition
::   let n be positive Nat;
::   let R be Ring;
::   let x, y be Matrix of n,R;
::   redefine func x * y -> Element of n-Matrices_over R;
::   correctness by MATRIX_1:2;
:: end;

:: definition
::   let n be positive Nat;
::   let R be Ring;
::   let x, y be Element of n-Matrices_over R;
::   redefine func x * y -> Element of n-Matrices_over R;
::   correctness by MATRIX_1:2;
:: end;

:: definition
::   let n be positive Nat;
::   let R be Ring;
::   let A be non empty (n,R)-matrix-membered 1-sorted;
::   let x, y be Element of A;
::   redefine func x * y -> Element of A;
:: ::>               *113
::   correctness by MATRIX_1:2;
:: end;

:: notation
::   let n,k,m be Nat;
::   let R be Ring;
::   let A be Matrix of n,k,R;
::   let B be Matrix of width A,m,R;
::   synonym matrix_mult(A,B) for A * B;
:: end;

definition
  let n be positive Nat;
  let R be Ring;
  func matrix_mult (n,R) -> BinOp of n-Matrices_over R means :Def3:
  for A,B being Element of n-Matrices_over R 
  holds it.(A,B) = A*B;
  existence
  proof
    set F1=n-Matrices_over R;
    defpred P[object, object, object] means ex X,Y,Z being Matrix of n,R
    st $1=X & $2=Y & $3=Z & Z = X*Y;

    A1: for x being object holds x in F1 iff x is Matrix of n,R
    proof
      let x be object;
      x is Element of F1 iff x is Matrix of n,R by MATRIX_1:2;
      hence thesis;
    end;
    
    A2: for x,y being object st x in F1 & y in F1 ex z being object st
    (z in F1 & P[x,y,z])
    proof
      let x,y be object;
      assume x in F1 & y in F1;
      then reconsider A=x, B=y as Matrix of n,R by A1;
      width A = n & len B = n by MATRIX_0:23;
      then reconsider B as Matrix of width A,n,R;
      take z = A*B;
      thus z in F1 by A1;
      thus P[x, y, z];
    end;
    
    consider f being Function of [: F1, F1 :],F1 such that
    A3: for x,y being object st x in F1 & y in F1 holds P[x, y, f.(x,y)]
    from BINOP_1:sch 1(A2);
    reconsider f as BinOp of F1;
    take f;
    for A,B being Element of F1 holds f.(A,B) = A*B
    proof
      let A,B be Element of F1;
      P[A, B, f.(A,B)] by A3;
      hence f.(A,B) = A*B;
    end;
    hence thesis;
  end;
  uniqueness
  proof
    let f,g be BinOp of n-Matrices_over R;
    set F1=n-Matrices_over R;
    assume A1: for A,B being Element of F1 holds f.(A,B) = A*B;
    assume A2: for A,B being Element of F1 holds g.(A,B) = A*B;
    for A,B being Element of F1 holds f.(A,B) = g.(A,B)
    proof
      let A,B be Element of F1;
      thus f.(A,B) = A*B by A1
                  .= g.(A,B) by A2;
    end;
    hence thesis;
  end;
end;
    
registration
  let R be Ring;
  let n be positive Nat;
  cluster strict non empty (n,R)-matrix-membered for multMagma;
  existence
  proof
    reconsider M = multMagma (# n-Matrices_over R, matrix_mult (n,R) #)
    as strict non empty multMagma;
    M is (n,R)-matrix-membered;
    hence thesis;
  end;
end;

definition
  let R be Ring;
  let n be positive Nat;
  func Mat(n,R) -> non empty (n,R)-matrix-membered multMagma equals :Def4:
  multMagma (# n-Matrices_over R, matrix_mult (n,R) #);
  coherence
  proof
    set M = multMagma (# n-Matrices_over R, matrix_mult (n,R) #);
    M is (n,R)-matrix-membered;
    hence thesis;
  end;
end;

theorem Th1:
  for R being commutative Ring
  for n
  holds Mat(n, R) is associative
proof
  let R be commutative Ring;
  let n be positive Nat;
  for x,y,z being Element of Mat (n, R) holds (x*y)*z=x*(y*z)
  proof
    let x,y,z be Element of Mat (n, R);
    reconsider X=x,Y=y,Z=z as Matrix of n,R by Def1;
    X*Y = x*y & Y*Z = y*z by Def3;
    then A1: (X*Y)*Z = (x*y)*z & X*(Y*Z) = x*(y*z) by Def3;
    width X = len Y & width Y = len Z
    proof
      width X = n & len Y = n & width Y = n & len Z = n by MATRIX_0:23;
      hence thesis;
    end;
    hence (x*y)*z=x*(y*z) by A1, MATRIX_3:33;
  end;
  hence Mat (n, R) is associative by GROUP_1:def 3;
end;

registration
  let R be commutative Ring;
  let n be positive Nat;
  cluster Mat(n,R) -> associative;
  correctness by Th1;
end;

theorem Th2:
  for A being Matrix of n,R
  holds A is Element of Mat(n, R) by MATRIX_1:2;

theorem Th3:
  1.(R,n) is Element of Mat(n, R) by MATRIX_1:2;

Lm2:
  for R being commutative Ring
  for e being Element of Mat(n,R) st e = 1.(R,n)
  for x being Element of Mat(n,R)
  holds (x * e = x & e * x = x)
proof
  let R be commutative Ring;
  let e be Element of Mat(n, R);
  assume A1: e=1.(R,n);
  let x be Element of Mat(n,R);
  reconsider X=x as Matrix of n,R by MATRIX_1:2;
  thus x * e = X * 1.(R,n) by A1,Def3
            .= x by MATRIX_3:19;
  thus e * x = 1.(R, n) * X by A1,Def3
            .= x by MATRIX_3:18;
end;

theorem Th4:
  for R being commutative Ring
  holds Mat (n, R) is unital
proof
  let R be commutative Ring;
  ex e being Element of Mat(n, R)
  st for x being Element of Mat(n,R)
  holds (x * e = x & e * x = x) 
  proof
    reconsider e=1.(R,n) as Element of Mat(n,R) by MATRIX_1:2;
    take e;
    thus thesis by Lm2;
  end;
  hence thesis by GROUP_1:def 1;
end;

registration
  let R be commutative Ring;
  let n be positive Nat;
  cluster Mat(n,R) -> unital associative;
  correctness by Th4;
end;

theorem Th5:
  for R being commutative Ring
  holds 1_(Mat(n,R)) = 1.(R, n)
proof
  let R be commutative Ring;
  reconsider e=1.(R,n) as Element of Mat(n,R) by MATRIX_1:2;
  for x being Element of Mat(n,R)
  holds x*e = x & e*x = x by Lm2;
  hence thesis by GROUP_1:def 4;
end;

begin :: The General Linear Group

reserve F for Field;

definition
  let n be positive Nat;
  let F be Field;
  let x be Element of Mat(n, F);
  attr x is invertible means :Def5:
  ex X being invertible Matrix of n,F st X = x;
end;

registration
  let n be positive Nat;
  let F be Field;
  cluster invertible for Element of Mat(n, F);
  existence
  proof
    take x = 1_(Mat(n,F));
    x = 1.(F,n) by Th5;
    hence thesis;
  end;
end;

definition
  let n be positive Nat;
  let F be Field;
  let x be Element of n-Matrices_over F;
  attr x is invertible means :Def6:
  ex X being invertible Matrix of n,F st X = x;
end;

registration
  let n be positive Nat;
  let F be Field;
  cluster invertible for Element of n-Matrices_over F;
  existence
  proof
    reconsider x=1.(F,n) as Element of n-Matrices_over F by MATRIX_1:2;
    take x;
    thus thesis;
  end;
end;

theorem Th6:
  for x being object
  holds x is invertible Element of n-Matrices_over F
  iff x is invertible Matrix of n,F
proof
  let x be object;
  hereby 
    assume x is invertible Element of n-Matrices_over F;
    then ex X being invertible Matrix of n,F st X = x by Def6;
    hence x is invertible Matrix of n,F;
  end;
  assume x is invertible Matrix of n,F;
  hence x is invertible Element of n-Matrices_over F by Def6,MATRIX_1:2;
end;


definition
  let F be Field;
  let n be positive Nat;
  func n-invertible_Matrices_over F -> non empty Subset of n-Matrices_over F
  means :Def7:
  for x being object holds x in it iff x is invertible Element of n-Matrices_over F;
  existence
  proof
    defpred P[object] means ex M being Matrix of n,F st M = $1 & M is invertible;
    deffunc F1() = n-Matrices_over F;
    consider B being Subset of F1() such that
    A1: for x being Element of F1() holds (x in B iff P[x])
    from SUBSET_1:sch 3;
    A2: for x being Element of n-Matrices_over F holds x in B iff x is invertible
    proof
      let x be Element of n-Matrices_over F;
      hereby 
        assume x in B;
        then P[x] by A1; 
        hence x is invertible;
      end;
      assume Z1: x is invertible;
      reconsider X=x as Element of n-Matrices_over F;
      thus x in B by A1,Z1;
    end;
    1.(F, n) is invertible Element of n-Matrices_over F by Th6; 
    then reconsider B as non empty Subset of n-Matrices_over F by A2;
    take B;
    thus thesis by A2;
  end;
  uniqueness
  proof
    let A,B be non empty Subset of n-Matrices_over F;
    assume A1: for x being object
    holds x in A iff x is invertible Element of n-Matrices_over F;
    assume A2: for x being object
    holds x in B iff x is invertible Element of n-Matrices_over F;
    
    for x being Element of n-Matrices_over F
    holds (x in A iff x in B)
    proof
      let x be Element of n-Matrices_over F;
      (x in A iff x is invertible) & (x in B iff x is invertible) by A1,A2;
      hence x in A iff x in B;
    end;
    hence A = B by SUBSET_1:3;
  end;
end;

theorem Th7:
  n-invertible_Matrices_over F is (matrix_mult (n,F))-binopclosed
proof
  set U = n-invertible_Matrices_over F;
  set V = n-Matrices_over F;
  for x being set st x in [: U, U :]
  holds (matrix_mult (n,F)).x in U
  proof
    let x be set;
    assume x in [: U, U :];
    then consider a,b being object such that
    A1: a in U & b in U & x = [a,b]
    by ZFMISC_1:def 2;
    reconsider A=a,B=b as Element of V by A1;
    A2: A * B is invertible Element of n-Matrices_over F
    proof
      A is invertible by A1, Def7;
      then consider X being invertible Matrix of n,F such that
      B1: X = A;
      B is invertible by A1, Def7;
      then consider Y being invertible Matrix of n,F such that
      B2: Y = B;
      reconsider Z = X * Y as invertible Matrix of n,F by MATRIX_6:36;
      Z = A*B by B1,B2;
      hence thesis by Def6, MATRIX_1:2;
    end;
    (matrix_mult (n,F)).x = (matrix_mult (n,F)).(A, B) by A1
                         .= A*B by Def3;
    hence (matrix_mult (n,F)).x in U by A2, Def7;
  end;
  hence thesis by REALSET1:def 1;
end;

definition
  let n be positive Nat;
  let F be Field;
  func GL(n, F) -> non empty (n,F)-matrix-membered strict multMagma
  means :Def8:
  the carrier of it = n-invertible_Matrices_over F
  & the multF of it = ((matrix_mult (n,F))||(the carrier of it));
  existence
  proof
    set U = n-invertible_Matrices_over F;
    set f = ((matrix_mult (n,F))||(U));
    set V = n-Matrices_over F;
    U is (matrix_mult (n,F))-binopclosed by Th7;
    then reconsider f as BinOp of U by REALSET1:2;
    set M = multMagma (# U, f #);
    for x being object st x in the carrier of M holds x is Matrix of n,F
    proof
      let x be object;
      assume x in the carrier of M;
      then x is Element of n-Matrices_over F;
      hence x is Matrix of n,F;
    end;

    then M is (n,F)-matrix-membered by Def1;
    then reconsider M as non empty (n,F)-matrix-membered strict multMagma;
    take M;
    thus the carrier of M = U;
    thus the multF of M = ((matrix_mult (n,F))||(the carrier of M));
  end;
  uniqueness;
end;

theorem Th8:
  for x being object
  holds x is Element of GL(n, F) iff x is invertible Matrix of n, F
proof
  let x be object;
  A1: x is invertible Element of n-Matrices_over F
      iff x is invertible Matrix of n,F by Th6;
  x is Element of n-invertible_Matrices_over F
  iff x is Element of GL(n, F) by Def8;
  hence thesis by A1,Def7;
end;

theorem Th9:
  1.(F,n) is Element of GL(n, F) by Th8;

theorem Th10:
  for x being object
  holds x is Element of GL(n, F)
    iff x is invertible Element of n-Matrices_over F
proof
  let x be object;
  thus x is Element of GL(n, F)
  implies x is invertible Element of n-Matrices_over F
  proof
    assume x is Element of GL(n, F);
    then reconsider X=x as Element of GL(n, F);
    X is Element of n-invertible_Matrices_over F by Def8;
    hence x is invertible Element of n-Matrices_over F by Def7;
  end;
  thus x is invertible Element of n-Matrices_over F
  implies x is Element of GL(n, F)
  proof
    assume x is invertible Element of n-Matrices_over F;
    then x is Element of n-invertible_Matrices_over F by Def7;
    hence x is Element of GL(n, F) by Def8;
  end;
end;

theorem Th11:
  for x,y being Element of GL(n,F)
  holds x * y = (matrix_mult (n, F)).(x, y)
proof
  let x,y be Element of GL(n,F);
  set U = n-invertible_Matrices_over F;
  A1: U = the carrier of GL(n, F) by Def8;
  x is Element of n-invertible_Matrices_over F
  & y is Element of n-invertible_Matrices_over F by Def8;
  then A2: [x,y] in [: U, U :] by ZFMISC_1:def 2;
  A3: ((matrix_mult (n, F))||U).(x,y)
         = ((matrix_mult (n, F))|[: U, U :]).([x,y]) by REALSET1:def 2
        .= (matrix_mult (n, F)).(x,y) by A2,FUNCT_1:49;
  thus x * y = (matrix_mult (n, F)).(x, y) by A1,A3,Def8;
end;

theorem Th12:
  for x,y being Element of GL(n,F)
  for X,Y being invertible Matrix of n, F st X = x & Y = y
  holds X * Y = x*y
proof
  let x,y be Element of GL(n,F);
  let X,Y be invertible Matrix of n, F;
  assume A1: X = x & Y = y;
  reconsider a=x, b=y as Element of n-Matrices_over F by Th10;
  thus x * y = (matrix_mult (n,F)).(x, y) by Th11
            .= a * b by Def3
            .= X * Y by A1;
end;

theorem Th13:
  GL(n, F) is associative
proof
  for x,y,z being Element of GL(n, F) holds (x*y)*z=x*(y*z)
  proof
    let x,y,z be Element of GL(n, F);
    reconsider X=x,Y=y,Z=z as invertible Matrix of n,F by Th8;
    A1: X*Y = x*y & Y*Z = y*z by Th12;
    X*Y is invertible Matrix of n,F & Y*Z is invertible Matrix of n,F
    by MATRIX_6:36;
    then A2: (X*Y)*Z = (x*y)*z & X*(Y*Z) = x*(y*z) by A1,Th12;
    width X = len Y & width Y = len Z
    proof
      width X = n & len Y = n & width Y = n & len Z = n by MATRIX_0:23;
      hence thesis;
    end;
    hence (x*y)*z=x*(y*z) by A2, MATRIX_3:33;
  end;
  hence GL(n, F) is associative by GROUP_1:def 3;
end;

registration
  let n be positive Nat;
  let F be Field;
  cluster GL(n, F) -> associative;
  correctness by Th13;
end;

Lm3:
  for e being Element of GL(n,F) st e = 1.(F,n)
  for x being Element of GL(n,F)
  holds (x * e = x & e * x = x)
proof
  let e be Element of GL(n, F);
  assume A1: e=1.(F,n);
  let x be Element of GL(n,F);
  reconsider X=x as invertible Matrix of n,F by Th8;
  A2: e is invertible Element of n-Matrices_over F &
      x is invertible Element of n-Matrices_over F by Th10;
  thus x * e = (matrix_mult (n,F)).(x, e) by Th11
            .= X * 1.(F,n) by A1,A2,Def3
            .= x by MATRIX_3:19;
  thus e * x = (matrix_mult (n,F)).(e, x) by Th11
            .= 1.(F, n) * X by A1,A2,Def3
            .= x by MATRIX_3:18;
end;

theorem Th14:
  GL(n, F) is Group-like
proof
  ex e being Element of GL(n, F) st
  for h being Element of GL(n, F) holds
  (h * e = h & e * h = h & ex g being Element of GL(n, F) st
  (h * g = e & g * h = e))
  proof
    reconsider e=1.(F,n) as Element of GL(n, F) by Th8;
    take e;
    let x be Element of GL(n, F);
    thus x * e = x & e * x = x by Lm3;
    reconsider X=x as invertible Matrix of n, F by Th8;
    consider Y being Matrix of n, F such that
    A1: Y is_reverse_of X by MATRIX_6:def 3;
    Y = X~ by A1, MATRIX_6:def 4;
    then reconsider Y as invertible Matrix of n, F;
    reconsider y=Y as Element of GL(n, F) by Th8;
    A2: y*x = Y*X by Th12
           .= X*Y by A1,MATRIX_6:def 2
           .= x*y by Th12;
    A3: y*x = Y*X by Th12
           .= e by A1,MATRIX_6:def 2;
    take y;
    thus thesis by A2,A3;
  end;
  hence thesis by GROUP_1:def 2;
end;

registration
  let n be positive Nat;
  let F be Field;
  cluster GL(n, F) -> Group-like;
  correctness by Th14;
end;

theorem Th15:
  GL(n, F) is strict Group;

theorem Th16:
  1_(GL(n,F)) = 1.(F, n)
proof
  reconsider e=1.(F,n) as Element of GL(n, F) by Th8;
  for x being Element of GL(n, F)
  holds (x * e = x & e * x = x) by Lm3;
  hence thesis by GROUP_1:def 4;
end;

theorem Th17:
  for x being Element of GL(n, F)
  for X being invertible Matrix of n,F st x = X
  holds x" = X~
proof
  let x be Element of GL(n, F);
  let X be invertible Matrix of n,F;
  assume A1: x = X;

  consider Y being Matrix of n, F such that
  A2: Y is_reverse_of X by MATRIX_6:def 3;
  Y = X~ by A2, MATRIX_6:def 4;
  then reconsider Y as invertible Matrix of n, F;
  reconsider y=Y as Element of GL(n, F) by Th8;
  A3: y*x = Y*X by A1,Th12
         .= X*Y by A2,MATRIX_6:def 2
         .= x*y by A1,Th12;
  y*x = Y*X by A1,Th12
     .= 1.(F,n) by A2,MATRIX_6:def 2
     .= 1_(GL(n, F)) by Th16;
  then x" = Y by A3, GROUP_1:def 5;
  hence x" = X~ by A2, MATRIX_6:def 4;
end;


::  MATRIX11:62 proves Det(A * B) = (Det A) * (Det B)
