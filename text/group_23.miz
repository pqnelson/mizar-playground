:: Properties of Direct Product Groups
::  by Alex Nelson
::
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.


environ

 vocabularies XCMPLX_0, INT_1, NEWTON, MSSUBFAM, TARSKI, NAT_1, QC_LANG1, RLSUB_1,
   XXREAL_0, ORDINAL4, XXREAL_1, BINOP_1, BINOP_2, RLVECT_2, ZFMISC_1,
   RELAT_1, STRUCT_0, FINSEQ_1, FUNCT_1, FUNCT_2, FUNCT_3, FUNCT_4,
   FUNCOP_1, NUMBERS, PRALG_1, ALGSTR_0, PARTFUN1, CARD_1, CARD_3, GROUP_1,
   GROUP_2, PRE_TOPC, GROUP_6, GROUP_7, GROUP_12, SUBSET_1, XBOOLE_0,
   PBOOLE, GROUP_19, GROUP_20, GROUP_23, SETFAM_1, REALSET1, GROUP_5,
   GROUP_4, ARYTM_1, ARYTM_0, ARYTM_3, SQUARE_1;

 constructors ORDINAL1, NAT_1, ZFMISC_1, BINOP_2, PBOOLE, BINOP_1,
   REALSET1, FUNCT_2, FUNCT_4, FUNCOP_1, NUMBERS, ARYTM_1, ARYTM_0, ARYTM_3,
   XCMPLX_0, MONOID_0, PRALG_1, GROUP_12, GROUP_6, GROUP_7, FUNCT_7,
   RELSET_1, FUNCT_3, PARTFUN1, GROUP_17, GRSOLV_1, ALGSTR_0, SETFAM_1,
   GROUP_19, FINSEQ_1, FINSOP_1, FINSEQOP, GROUP_2, GROUP_3, GROUP_5,
   INT_2, GROUP_1, FINSEQ_4, GROUP_4, SQUARE_1, INT_1;

 notations ZFMISC_1, TARSKI, XBOOLE_0, RELAT_1, SUBSET_1, RELSET_1,
   FUNCT_1, BINOP_1, BINOP_2, REALSET1, FUNCT_2, FUNCT_4, FUNCT_7,
   FUNCOP_1, PBOOLE, ARYTM_1, ARYTM_3, NAT_1, CARD_3, ORDINAL1, NUMBERS,
   XXREAL_0, SQUARE_1, INT_1, DOMAIN_1, STRUCT_0, XCMPLX_0, MONOID_0, PARTFUN1,
   GROUP_17, ALGSTR_0, SETFAM_1, PRALG_1, GROUP_12, GROUP_7, FINSOP_1,
   FINSEQ_1, FINSEQOP, FINSEQ_2, GROUP_6, GRSOLV_1, GROUP_2, GROUP_3,
   GROUP_5, GROUP_1, GROUP_4;
   :: GROUP_6, GROUP_4, GRSOLV_1, GROUP_1, GROUP_2, GROUP_3, GROUP_5;

 registrations XBOOLE_0, STRUCT_0, ALGSTR_0, GROUP_1, GROUP_2,
   MONOID_0, NAT_1, RELAT_1, FUNCT_1, PARTFUN1, REALSET1, RELSET_1,
   NUMBERS, XCMPLX_0, XXREAL_0, XREAL_0, XXREAL_2, INT_2, SQUARE_1,
   FUNCT_2, FUNCOP_1, CARD_3, FINSET_1, FINSEQ_1, CARD_1,
   ORDINAL1, INT_1,
   BINOP_1, GROUP_3, GROUP_6, GR_CY_1, FUNCT_7, GROUP_7, GROUP_12,
   PRALG_1, PBOOLE, GROUP_22;

 definitions STRUCT_0, TARSKI, SUBSET_1, RELAT_1, FUNCT_1, FUNCT_2,
   FUNCOP_1, GROUP_4, ORDINAL1;

 equalities TARSKI, FUNCT_7, FINSET_1, ALGSTR_0, GROUP_1, GROUP_2,
   :: GROUP_6,
   STRUCT_0, BINOP_1, FUNCT_1, FUNCT_2, PRALG_1, GROUP_7,
   GROUP_4;

 expansions TARSKI, FUNCT_7, FINSET_1, ALGSTR_0, GROUP_1, GROUP_2,
   :: GROUP_6,
   STRUCT_0, BINOP_1, FUNCT_1, FUNCT_2, PRALG_1, GROUP_7;

 theorems TARSKI, FUNCT_1, FUNCT_2, FUNCT_7, FUNCOP_1, CARD_3, GROUP_1,
   GROUP_2, GROUP_3, GROUP_5, GROUP_6, GROUP_7, GROUP_12, PARTFUN1,
   PRALG_1, GROUP_19, SETFAM_1, XBOOLE_0, GROUP_21, SUBSET_1, PBOOLE,
   GRSOLV_1, RELAT_1, STRUCT_0, GROUP_22, XBOOLE_1, FUNCT_5, BINOP_1,
   ZFMISC_1, REALSET1, ALGSTR_0, FINSEQ_1, FINSOP_1, NAT_1, FINSEQOP,
   GROUP_4, FINSEQ_2, GROUP_20, PARTFUN2;

 requirements BOOLE, SUBSET, NUMERALS, ARITHM, REAL;

 schemes FUNCT_1, FUNCT_2, PBOOLE, FINSEQ_1, FINSEQ_2, INT_1;

begin :: Sequences of group elements

theorem LmPowers:
  for G being Group
  for H being Subgroup of G
  for n being Element of INT
  for g being Element of G
  for h being Element of H st g = h
  holds g |^ n = h |^ n by GROUP_4:2;

theorem FrobProdSubgroup:
  for G being Group
  for H being Subgroup of G
  for hs being FinSequence of the carrier of H
  for gs being FinSequence of the carrier of G st gs = hs
  for ks being FinSequence of INT st len ks = len gs
  holds Product (gs |^ ks) = Product (hs |^ ks)
proof
  let G be Group;
  let H be Subgroup of G;
  let hs be FinSequence of the carrier of H;
  let gs be FinSequence of the carrier of G;
  assume A1: gs = hs;
  let ks be FinSequence of INT;
  assume A2: len ks = len gs;

  
  A3: len (gs |^ ks) = len (hs |^ ks)
  proof
    thus len (hs |^ ks) = len hs by GROUP_4:def 3
                       .= len gs by A1, FINSEQ_1:def 17
                       .= len (gs |^ ks) by GROUP_4:def 3;
  end;
  A4: dom gs = dom hs by A1;
  for i being Nat st 1 <= i & i <= len (hs |^ ks)
  holds (hs |^ ks).i = (gs |^ ks).i
  proof
    let i be Nat;
    assume B1: 1 <= i;
    assume B2: i <= len (hs |^ ks);
    then i <= len hs by GROUP_4:def 3;
    then B2b: i in Seg (len hs) by B1, FINSEQ_1:1;
    then B3: i in dom hs by FINSEQ_1:def 2, FINSEQ_1:def 3;
    B4: hs /. i = gs /. i
    proof
      reconsider hsi = hs/.i as Element of G by GROUP_2:42;
      C1: i in dom gs & dom gs = dom hs by B3,A4;
      C2: hsi = hs/.i by C1, GROUP_2:42;
      C3: gs.i = gs/.i by C1, PARTFUN1:def 6;
      hs.i = gs.i by A1, B3, C1;
      then gs/.i = hsi by C1, C3, PARTFUN1:def 6;
      hence thesis;
    end;
    (hs |^ ks).i = (hs /. i) |^ (@ (ks /. i)) by B3, GROUP_4:def 3
    .= (gs /. i) |^ (@ (ks /. i)) by B4, GROUP_4:2
    .= (gs |^ ks).i by A4, B3, GROUP_4:2, GROUP_4:def 3;
    hence (hs |^ ks).i = (gs |^ ks).i;
  end;

  then A4: hs |^ ks = gs |^ ks by A3, FINSEQ_1:def 17;
  hence thesis by GROUP_19:45;
end;

begin :: Preliminary Work about Group-Families and Group-Yielding Many Sorted Sets
definition
  let IT be Relation;
  attr IT is Group-yielding means :Def1:
  for y being object st y in rng IT holds
  y is Group;
end;

registration
  cluster Group-yielding -> 1-sorted-yielding for Function;
  coherence;
  cluster Group-yielding -> multMagma-yielding for Function;
  coherence;
end;

Lm1:
  for I being set
  for F being associative Group-like multMagma-Family of I
  holds F is Group-yielding
proof
  let I be set;
  let F be associative Group-like multMagma-Family of I;
  for y being object st y in rng F
  holds y is Group
  proof
    let y be object;
    assume y in rng F;
    then ex x being object st x in dom F & y = F.x by FUNCT_1:def 3;
    hence y is Group by GROUP_19:1;
  end;
  hence F is Group-yielding;
end;

registration
  let I be set;
  cluster Group-yielding for ManySortedSet of I;
  existence
  proof
    set G = the trivial Group;
    set f = I --> G;
    take f;
    let a be object;
    assume a in rng f;
    then ex x being object st x in dom f & a = f.x by FUNCT_1:def 3;
    hence thesis by FUNCOP_1:7;
  end;
end;
registration
  let I be set;
  cluster Group-yielding -> 1-sorted-yielding for ManySortedSet of I;
  coherence;
  cluster Group-yielding -> multMagma-yielding for ManySortedSet of I;
  coherence;
end;

registration
  cluster Group-yielding for Function;
  existence
  proof
    set I = the set, f = the Group-yielding ManySortedSet of I;
    take f;
    thus thesis;
  end;
end;

theorem Lm4:
  for I being non empty set
  for F being Group-yielding ManySortedSet of I
  for i being Element of I
  holds F.i is Group
proof
  let I be non empty set;
  let F be Group-yielding ManySortedSet of I;
  let i be Element of I;
  i in I & dom F = I by PARTFUN1:def 2;
  then F.i in rng F by FUNCT_1:3;
  hence F.i is Group by Def1;
end;

registration
  let I be non empty set;
  let i be Element of I;
  let F be Group-yielding ManySortedSet of I;
  cluster (F . i) -> Group-like associative unital non empty for multMagma;
  correctness by Lm4;
end;

registration
  let I be set;
  cluster associative Group-like -> Group-yielding for multMagma-Family of I;
  coherence by Lm1;
end;

theorem
  for I being non empty set
  for F being Group-yielding ManySortedSet of I
  for i being object st i in I
  ex G being Group st [i, G] in F
proof
  let I be non empty set;
  let F be Group-yielding ManySortedSet of I;
  let i be object;
  assume A1: i in I;
  then A2: i in dom F by PARTFUN1:def 2;
  F.i is Group by A1, Lm4;
  then consider G being Group such that
  A3: G = F.i;
  take G;
  thus [i, G] in F by A2, A3, FUNCT_1:def 2;
end;

registration
  let I be set;
  cluster Group-yielding -> Group-like associative for multMagma-Family of I;
  correctness
  proof
    thus for F being multMagma-Family of I st F is Group-yielding
    holds F is Group-like associative
    proof
      let F be multMagma-Family of I;
      assume A1: F is Group-yielding;
      A2: dom F = I by PARTFUN1:def 2;
      for i being set st i in I
      ex Fi being non empty Group-like multMagma st Fi = F.i
      proof
        let i be set;
        assume i in I;
        then F.i is Group by A1, A2, FUNCT_1:3;
        hence thesis;
      end;
      then A3: F is Group-like;
      for i being set st i in I
      ex Fi being non empty associative multMagma st Fi = F.i
      proof
        let i be set;
        assume i in I;
        then F.i is Group by A1, A2, FUNCT_1:3;
        hence thesis;
      end;
      hence F is Group-like associative by A3;
    end;
  end;
end;

registration
  let I be set;
  cluster -> Group-yielding for Group-like associative multMagma-Family of I;
  coherence;
end;

definition
  let I be set;
  mode Group-Family of I is Group-yielding ManySortedSet of I;
end;

reserve I for non empty set;
reserve i for Element of I;
reserve F for Group-Family of I;
reserve G for Group;

theorem LmEmptyGroupFamilyExplicit:
  {} --> G is Group-Family of {}
proof
  {} --> G is ManySortedSet of {} & {} --> G is Group-yielding;
  hence {} --> G is Group-Family of {};
end;

theorem Th4:
  for n being Nat
  holds Seg n --> G is Group-Family of Seg n
proof
  let n be Nat;
  per cases;
  suppose Seg n is empty;
    hence thesis by LmEmptyGroupFamilyExplicit;
  end;
  suppose A1: not (Seg n is empty);
    for y being object st y in rng (Seg n --> G) holds y is Group
    proof
      let y be object;
      assume y in rng (Seg n --> G);
      then y in {G} by A1, FUNCOP_1:8;
      hence y is Group by TARSKI:def 1;
    end;
    then Seg n --> G is Group-yielding;
    hence Seg n --> G is Group-Family of Seg n;
  end;
end;

registration
  let G be Group;
  let n be Nat;
  cluster (Seg n --> G) -> Group-yielding;
  correctness by Th4;
end;

theorem ThCarr:
  (Carrier F).i = the carrier of F.i
proof
  ex R being 1-sorted st (R = F.i & (Carrier F).i = the carrier of R)
  by PRALG_1:def 15;
  hence thesis;
end;


begin :: Subgroup-Family of a Family of Groups
definition
  let I be set;
  let F, IT be Group-Family of I;
  attr IT is F-Subgroup-yielding means :Def3:
  for i being Element of I
  for G being Group st G = F.i
  holds IT.i is Subgroup of G;
end;

theorem
  for S being Group-Family of I
  holds S is F-Subgroup-yielding iff (for i being Element of I holds S.i
  is Subgroup of F.i);

theorem ThSubYieldRefl:
  F is F-Subgroup-yielding by GROUP_2:54;

registration
  let I be non empty set;
  let F be Group-Family of I;
  cluster F-Subgroup-yielding for Group-Family of I;
  existence by ThSubYieldRefl;
end;

definition
  let I be non empty set;
  let F be Group-Family of I;
  mode Subgroup-Family of F is F-Subgroup-yielding Group-Family of I;
end;

definition
  let I be non empty set;
  let F be Group-Family of I;
  let S be Subgroup-Family of F;
  let i be Element of I;
  redefine func S.i -> Subgroup of F.i;
  correctness by Def3;
end;

reserve S for Subgroup-Family of F;

theorem
  for S being Group-Family of I
  holds S is Subgroup-Family of F iff (for i being Element of I
  holds S.i is Subgroup of F.i)
proof
  let S be Group-Family of I;
  thus (S is Subgroup-Family of F) implies (for i being Element of I
  holds S.i is Subgroup of F.i)
  proof
    assume A1: S is Subgroup-Family of F;
    let i be Element of I;
    reconsider SS=S as Subgroup-Family of F by A1;
    S.i = SS.i;
    hence thesis;
  end;
  assume Z2: for i being Element of I holds S.i is Subgroup of F.i;
  then for i being Element of I
  for G being Group st G = F.i
  holds S.i is Subgroup of G;
  then S is F-Subgroup-yielding by Def3;
  hence S is Subgroup-Family of F;
end;

scheme
GrFamSch { I1() -> non empty set,
           Fun(Element of I1()) -> Group } :
  ex Fam being Group-Family of I1()
  st for i being Element of I1() holds Fam.i = Fun(i)
proof
  consider F being ManySortedSet of I1() such that
  A1: for i being Element of I1() holds F.i = Fun(i)
  from PBOOLE:sch 5;
  for y being object st y in rng F holds y is Group
  proof
    let y be object;
    assume B1: y in rng F;
    then consider x being object such that
    B2: x in dom F & y = F.x
    by FUNCT_1:def 3;
    reconsider i=x as Element of I1() by B2;
    y = F.i by B2
     .= Fun(i) by A1;
    hence y is Group;
  end;
  then F is Group-yielding;
  then reconsider F as Group-Family of I1();
  take F;
  thus thesis by A1;
end;

scheme
SubFamSch { I1() -> non empty set,
            Fam() -> Group-Family of I1(),
            Sub(Group) -> Group } :
  ex S being Subgroup-Family of Fam()
  st for i being Element of I1() holds S.i = Sub(Fam().i)
provided
A1: for G being Group holds Sub(G) is Subgroup of G
proof
  deffunc F2(Element of I1()) = Sub(Fam().$1);
  consider S being ManySortedSet of I1() such that
  A2: for i being Element of I1() holds S.i = F2(i)
  from PBOOLE:sch 5;
  for y being object st y in rng S holds y is Group
  proof
    let y be object;
    assume B1: y in rng S;
    then consider x being object such that
    B2: x in dom S & y = S.x
    by FUNCT_1:def 3;
    reconsider i=x as Element of I1() by B2;
    y = S.i by B2
     .= F2(i) by A2;
    hence y is Group;
  end;

  then S is Group-yielding;
  then reconsider S as Group-Family of I1();
  for i being Element of I1() holds S.i is Subgroup of Fam().i
  proof
    let i be Element of I1();
    S.i = Sub(Fam().i) by A2;
    hence S.i is Subgroup of Fam().i by A1;
  end;
  then S is Fam()-Subgroup-yielding;
  then reconsider S as Subgroup-Family of Fam();
  take S;
  thus thesis by A2;
end;

:: Re-defining "strict" for Subgroup-Family seemed like a risky move,
:: so I opted to introduce an adjective which captured what was needed.
definition
  let I be non empty set;
  let IT be Group-Family of I;
  attr IT is componentwise_strict means :Def4:
  for i being Element of I holds IT.i is strict Group;
end;

registration
  let I be non empty set;
  cluster componentwise_strict for Group-Family of I;
  existence
  proof
    reconsider G = multMagma (# REAL, addreal #) as strict Group
    by GROUP_1:46;
    deffunc Fun(Element of I) = G;
    consider F being Group-Family of I such that
    A1: for i being Element of I holds F.i = Fun(i)
    from GrFamSch;
    take F;
    for i being Element of I holds F.i is strict Group by A1;
    hence thesis;
  end;
end;

definition
  let I be non empty set;
  let F be Group-Family of I;
  let IT be Subgroup-Family of F;
  attr IT is componentwise_strict means :Def5:
  for i being Element of I holds IT.i is strict Subgroup of F.i;
end;

registration
  let I be non empty set;
  let F be Group-Family of I;
  cluster componentwise_strict for Subgroup-Family of F;
  existence
  proof
    deffunc Sub(Group) = (1).$1;
    A1: for G being Group holds Sub(G) is Subgroup of G;
    consider S being Subgroup-Family of F such that
    A2: for i being Element of I holds S.i = Sub(F.i)
    from SubFamSch(A1);
    take S;
    for i being Element of I holds S.i is strict Subgroup of F.i
    proof
      let i be Element of I;
      S.i = Sub(F.i) by A2
         .= (1).(F.i);
      hence thesis;
    end;
    hence thesis;
  end;
end;

registration
  let I be non empty set;
  let F be Group-Family of I;
  let S be componentwise_strict Subgroup-Family of F;
  let i be Element of I;
  cluster (S . i) -> strict for Subgroup of F.i;
  correctness by Def5;
end;

theorem
  for S being componentwise_strict Subgroup-Family of F
  holds S is componentwise_strict Group-Family of I
proof
  let S be componentwise_strict Subgroup-Family of F;
  for i being Element of I
  holds S.i is strict Group;
  hence S is componentwise_strict Group-Family of I by Def4;
end;

scheme
StrSubFamSch { I1() -> non empty set,
               Fam() -> Group-Family of I1(),
               Sub(Group) -> Group } :
  ex S being componentwise_strict Subgroup-Family of Fam()
  st for i being Element of I1() holds S.i = Sub(Fam().i)
provided
A1: for G being Group holds Sub(G) is strict Subgroup of G
proof
  A2: for G being Group holds Sub(G) is Subgroup of G by A1;
  consider S being Subgroup-Family of Fam() such that
  A3: for i being Element of I1() holds S.i = Sub(Fam().i)
  from SubFamSch(A2);
  for i being Element of I1()
  holds S.i is strict Subgroup of Fam().i
  proof
    let i be Element of I1();
    S.i = Sub(Fam().i) by A3;
    hence S.i is strict Subgroup of Fam().i by A1;
  end;
  then S is componentwise_strict;
  then reconsider S as componentwise_strict Subgroup-Family of Fam();
  take S;
  thus thesis by A3;
end;

theorem ThStrSubEq:
  for A,B being componentwise_strict Subgroup-Family of F
  st (for i being Element of I holds A.i = B.i)
  holds A = B
proof
  let A,B be componentwise_strict Subgroup-Family of F;
  assume for i being Element of I holds A.i = B.i;
  then for i being object st i in I holds A.i = B.i;
  hence A = B by PBOOLE:3;
end;

definition
  let I be non empty set;
  let F be Group-Family of I;
  func (1).F -> componentwise_strict Subgroup-Family of F means
  :Def6:
  for i being Element of I
  holds it.i = (1).(F.i);
  existence
  proof
    deffunc Sub(Group) = (1).$1;
    A1: for G being Group holds Sub(G) is strict Subgroup of G;
    thus ex S being componentwise_strict Subgroup-Family of F
    st for i being Element of I holds S.i = Sub(F.i)
    from StrSubFamSch(A1);
  end;
  uniqueness
  proof
    thus for A,B being componentwise_strict Subgroup-Family of F
    st (for i being Element of I holds A.i = (1).(F.i))
    & (for i being Element of I holds B.i = (1).(F.i))
    holds A = B
    proof
      let A,B be componentwise_strict Subgroup-Family of F;
      assume A1: for i being Element of I holds A.i = (1).(F.i);
      assume A2: for i being Element of I holds B.i = (1).(F.i);
      for i being Element of I holds A.i = B.i
      proof
        let i be Element of I;
        thus A.i = (1).(F.i) by A1
                .= B.i by A2;
      end;
      hence thesis by ThStrSubEq;
    end;
  end;
end;

definition
  let I be non empty set;
  let F be Group-Family of I;
  func (Omega).F -> componentwise_strict Subgroup-Family of F means
  :Def7:
  for i being Element of I
  holds it.i = (Omega).(F.i);
  existence
  proof
    deffunc Sub(Group) = (Omega).$1;
    A1: for G being Group holds Sub(G) is strict Subgroup of G;
    thus ex S being componentwise_strict Subgroup-Family of F
    st for i being Element of I holds S.i = Sub(F.i)
    from StrSubFamSch(A1);
  end;
  uniqueness
  proof
    thus for A,B being componentwise_strict Subgroup-Family of F
    st (for i being Element of I holds A.i = (Omega).(F.i))
    & (for i being Element of I holds B.i = (Omega).(F.i))
    holds A = B
    proof
      let A,B be componentwise_strict Subgroup-Family of F;
      assume A1: for i being Element of I holds A.i = (Omega).(F.i);
      assume A2: for i being Element of I holds B.i = (Omega).(F.i);
      for i being Element of I holds A.i = B.i
      proof
        let i be Element of I;
        thus A.i = (Omega).(F.i) by A1
                .= B.i by A2;
      end;
      hence thesis by ThStrSubEq;
    end;
  end;
end;

definition
  let I be non empty set;
  let F be Group-Family of I;
  let IT be Subgroup-Family of F;
  attr IT is normal means :Def8:
  for i being Element of I holds IT.i is normal Subgroup of F.i;
end;

registration
  let I be non empty set;
  let F be Group-Family of I;
  cluster componentwise_strict normal for Subgroup-Family of F;
  existence
  proof
    deffunc Sub(Group) = (1).$1;
    A1: for G being Group holds Sub(G) is strict Subgroup of G;
    consider S being componentwise_strict Subgroup-Family of F such that
    A2: for i being Element of I holds S.i = Sub(F.i)
    from StrSubFamSch(A1);
    take S;
    for i being Element of I holds S.i is normal Subgroup of F.i
    proof
      let i be Element of I;
      S.i = (1).(F.i) by A2;
      hence thesis;
    end;
    hence thesis;
  end;
end;

registration
  let I be non empty set;
  let F be Group-Family of I;
  let S be normal Subgroup-Family of F;
  let i be Element of I;
  cluster (S . i) -> normal for Subgroup of F.i;
  correctness by Def8;
end;

registration
  let I be non empty set;
  let F be Group-Family of I;
  let S be componentwise_strict normal Subgroup-Family of F;
  let i be Element of I;
  cluster (S . i) -> strict normal for Subgroup of F.i;
  correctness;
end;

definition
  let I be non empty set;
  let F be Group-Family of I;
  let N be normal Subgroup-Family of F;
  func F ./. N -> Group-Family of I means :Def9:
  for i being Element of I
  holds it.i = (F.i) ./. (N.i);
  existence
  proof
    deffunc Fun(Element of I) = (F.$1) ./. (N.$1);
    thus ex Fam being Group-Family of I
    st for i being Element of I holds Fam.i = Fun(i)
    from GrFamSch;
  end;
  uniqueness
  proof
    thus for A, B being Group-Family of I
    st (for i being Element of I holds A.i = (F.i) ./. (N.i))
    & (for i being Element of I holds B.i = (F.i) ./. (N.i))
    holds A = B
    proof
      let A, B be Group-Family of I;
      assume A1: for i being Element of I holds A.i = (F.i) ./. (N.i);
      assume A2: for i being Element of I holds B.i = (F.i) ./. (N.i);
      for i being object st i in I
      holds A.i = B.i
      proof
        let i be object;
        assume B1: i in I;
        then reconsider j=i as Element of I;
        A.j = (F.j) ./. (N.j) by A1
           .= B.j by A2;
        hence thesis;
      end;
      hence A = B by PBOOLE:3;
    end;
  end;
end;

theorem
  ex S being componentwise_strict normal Subgroup-Family of F
  st for i being Element of I holds S.i = (F.i)`
proof
  deffunc Fun(Group) = ($1)`;
  A1: for G being Group holds Fun(G) is strict Subgroup of G;
  consider S being componentwise_strict Subgroup-Family of F such that
  A2: for i being Element of I holds S.i = Fun(F.i)
  from StrSubFamSch(A1);
  for i being Element of I holds S.i is normal Subgroup of F.i
  proof
    let i be Element of I;
    S.i = (F.i)` by A2;
    hence S.i is normal Subgroup of F.i;
  end;
  then reconsider S as componentwise_strict normal Subgroup-Family of F
  by Def8;
  take S;
  thus thesis by A2;
end;

theorem LmTriv:
  for M being strict multMagma
  st (ex x being object st the carrier of M = {x})
  ex G being strict trivial Group st M=G
proof
  let M be strict multMagma;
  given x being object such that 
  A1: the carrier of M = {x};
  reconsider M as non empty multMagma by A1;
  reconsider x as Element of M by A1, TARSKI:def 1;
  for a,b,c being Element of M holds (a * b) * c = a * (b * c)
  proof
    let a,b,c be Element of M;
    (a * b) * c = x & a * (b * c) = x by A1, TARSKI:def 1;
    hence (a * b) * c = a * (b * c);
  end;
  then A2: M is associative;
  
  ex e being Element of M st
  for h being Element of M holds
  (h * e = h & e * h = h & ex g being Element of M st (h * g = e & g * h = e))
  proof
    take e = x;
    let h be Element of M;
    h = x by A1, TARSKI:def 1;
    hence h * e = h & e * h = h by A1, TARSKI:def 1;
    take g = x;
    thus thesis by A1, TARSKI:def 1;
  end;
  then M is Group-like;
  then reconsider G=M as strict trivial Group by A1, A2;
  take G;
  thus thesis;
end;

theorem
  for I being empty set
  for F being multMagma-Family of I
  holds product F is trivial Group
proof
  let I be empty set;
  let F be multMagma-Family of I;
  product (Carrier F) = {{}} by CARD_3:10;
  then ex G being strict trivial Group st (product F)=G
  by LmTriv, GROUP_7:def 2;
  hence thesis;
end;

begin :: Inclusion Morphism
definition
  let G, H be Group;
  assume A1: H is Subgroup of G;
  func incl (H, G) -> Homomorphism of H, G
  equals :DefIncl: id (the carrier of H);
  coherence
  proof
    set f = id (the carrier of H);
    f is Function of the carrier of H, the carrier of G
    proof
      B1: dom f = the carrier of H;
      rng f c= the carrier of G by A1, GROUP_2:def 5;
      hence f is Function of the carrier of H, the carrier of G
      by B1, FUNCT_2:2;
    end;
    then reconsider f as Function of H, G;
    for g,h being Element of H
    holds f.(g * h) = (f.g) * (f.h) by A1, GROUP_2:43;
    hence id (the carrier of H) is Homomorphism of H, G by GROUP_6:def 6;
  end;
end;

definition
  let G be Group, H be Subgroup of G;
  func incl H -> Homomorphism of H,G equals incl (H, G);
  coherence;
end;

theorem Th8:
  for H being Group
  for h being Element of H
  st H is Subgroup of G
  holds (incl (H, G)).h = h
proof
  let H be Group;
  let h be Element of H;
  assume H is Subgroup of G;
  hence (incl (H, G)).h = (id the carrier of H).h by DefIncl
                       .= h;
end;

theorem Th9:
  for H being Subgroup of G
  holds incl (H, G) is one-to-one
  & Image (incl (H, G)) = the multMagma of H
proof
  let H be Subgroup of G;
  set f = incl (H, G);
  A1: f = id (the carrier of H) by DefIncl;
  the carrier of H = rng f by A1
                  .= the carrier of (Image f) by GROUP_6:44;
  then A2: Image f = the multMagma of H by GROUP_2:59;
  
  Ker f = (1).H
  proof
    for h being Element of H holds h in Ker f iff h in (1).H
    proof
      let h be Element of H;
      hereby 
        assume h in Ker f;
        then f.h = 1_G by GROUP_6:41
                .= 1_H by GROUP_2:44;
        then h in {1_H} by A1, TARSKI:def 1;
        hence h in (1).H by GROUP_2:def 7;
      end;
      assume h in (1).H;
      then h in {1_H} by GROUP_2:def 7;
      then h = 1_H by TARSKI:def 1;
      then f.h = 1_G by GROUP_6:31;
      hence h in Ker f by GROUP_6:41;
    end;
    hence thesis;
  end;
  hence f is one-to-one by GROUP_6:56;
  thus Image f = the multMagma of H by A2;
end;

registration
  let G be Group, H be Subgroup of G;
  cluster incl (H, G) -> one-to-one;
  correctness by Th9;
end;

theorem
  for H,K being Group st H is Subgroup of G
  for phi being Homomorphism of G,K
  holds phi|(the carrier of H) = phi * (incl (H, G))
proof
  let H,K be Group;
  assume A1: H is Subgroup of G;
  let phi be Homomorphism of G,K;
  A2: dom (phi|(the carrier of H)) = the carrier of H
  proof
    dom phi = the carrier of G by FUNCT_2:def 1;
    hence dom (phi|(the carrier of H)) = the carrier of H
    by A1, GROUP_2:def 5, RELAT_1:62;
  end;
  for x being object st x in dom (phi|(the carrier of H))
  holds (phi|(the carrier of H)).x = (phi * (incl (H, G))).x
  proof
    let x be object;
    assume B1: x in dom (phi|(the carrier of H));
    thus (phi * (incl (H, G))).x
     = phi.((incl (H, G)).x) by B1, A2, FUNCT_2:15
    .= phi.x by A1, A2, B1, Th8
    .= (phi|(the carrier of H)).x by B1, FUNCT_1:47;
  end;

  hence phi|(the carrier of H) = phi * (incl (H, G))
  by A2, FUNCT_2:def 1;
end;

theorem Th17b:
  for K being Group
  for H being Subgroup of G
  for phi being Homomorphism of G,K
  holds phi|H = phi * (incl H)
proof
  let K be Group;
  let H be Subgroup of G;
  let phi be Homomorphism of G,K;
  for h being Element of H holds
  (phi|H).h = (phi * (incl H)).h
  proof
    let h be Element of H;
    (incl H).h = (id (the carrier of H)).h 
    & dom (incl H) = the carrier of H by DefIncl, FUNCT_2:def 1;
    then A1: (phi * (incl H)).h = phi.h by FUNCT_1:13;
    h in G by GROUP_2:41;
    then h in dom phi by FUNCT_2:def 1; 
    then h in (dom phi) /\ (the carrier of H) by XBOOLE_0:def 4;
    then (phi|the carrier of H).h = phi.h by FUNCT_1:48;
    hence (phi|H).h = (phi * (incl H)).h by A1, GRSOLV_1:def 2;
  end;
  hence phi|H = phi * (incl H);
end;

theorem Th64e:
  for G being Group
  for H being strict Subgroup of G
  holds Image(incl H) = H
proof
  let G be Group;
  let H be strict Subgroup of G;
  (the carrier of H) c= (the carrier of H);
  then (the carrier of H) is Subset of (the carrier of H);
  then the carrier of H
   = (id the carrier of H) .: (the carrier of H) by FUNCT_1:92
  .= (incl H) .: (the carrier of H) by DefIncl
  .= the carrier of Image (incl H) by GROUP_6:def 10;
  hence Image(incl H) = H by GROUP_2:59;
end;

begin :: Universal Property of Null Group
:: Uniqueness of morphisms to the trivial group
theorem Th11:
  for H being trivial Group
  for f1,f2 being Homomorphism of G,H
  holds f1=f2
proof
  let H be trivial Group;
  let f1,f2 be Homomorphism of G,H;
  A1: the carrier of H = {1_H}
  proof
    H is trivial;
    then consider x being object such that
    B1: the carrier of H = {x} by GROUP_6:def 2;
    thus thesis by B1, TARSKI:def 1;
  end;

  for g being object st g in the carrier of G holds f1.g = f2.g
  proof
    let g be object;
    assume B1: g in the carrier of G;
    f1.g in H by B1, FUNCT_2:5;
    then B2: f1.g = 1_H by A1, TARSKI:def 1;
    f2.g in H by B1, FUNCT_2:5;
    hence f1.g = f2.g by A1, B2, TARSKI:def 1;
  end;
  hence f1=f2;
end;

:: Universal property of terminal object for the trivial group
theorem
  for H being trivial Group
  ex h being Homomorphism of G,H 
  st (for f being Homomorphism of G,H holds h=f)
proof
  let H be trivial Group;
  take h = 1:(G,H);
  thus thesis by Th11;
end;

theorem
  for H being trivial Group
  for f being Homomorphism of G,H
  for g being Element of G
  holds f.g = 1_H
proof
  let H be trivial Group;
  let f be Homomorphism of G,H;
  let g be Element of G;
  thus f.g = (1:(G,H)).g by Th11
          .= (G --> 1_H).g by GROUP_6:def 7
          .= 1_H by FUNCOP_1:7;
end;

theorem
  for H being trivial Group
  holds Image (1:(H,G)) = (1).G & (1:(H,G)) is one-to-one
proof
  let H be trivial Group;
  thus Image (1:(H,G)) = (1).G by GROUP_6:47;
  the multMagma of H = (1).H by GROUP_22:6;
  then Ker (1:(H,G)) is Subgroup of (1).H
  by GROUP_2:57, GROUP_2:def 5;
  then Ker (1:(H,G)) is trivial Subgroup of H by GROUP_22:9;
  then Ker (1:(H,G)) = (1).H by GROUP_22:8;
  hence (1:(H,G)) is one-to-one by GROUP_6:56;
end;

theorem Th15:
  for H being trivial Group
  for f1, f2 being Homomorphism of H, G
  holds f1 = f2
proof
  let H be trivial Group;
  let f1, f2 be Homomorphism of H, G;
  for h being Element of H holds f1.h = f2.h
  proof
    let h be Element of H;
    the multMagma of H = (1).H by GROUP_22:6;
    then the carrier of H = {1_H} by GROUP_2:def 7;
    then B1: h = 1_H by TARSKI:def 1;
    hence f1.h = 1_G by GROUP_6:31
              .= f2.h by B1, GROUP_6:31;
  end;
  hence f1 = f2;
end;

:: Universal property of initial object for the trivial group
theorem
  for H being trivial Group
  ex h being Homomorphism of H, G
  st (for f being Homomorphism of H, G holds h=f)
proof
  let H be trivial Group;
  take h = 1:(H,G);
  thus thesis by Th15;
end;

theorem Th25:
  for G1, G2 being Group
  for H being Subgroup of G2
  for f being Homomorphism of G1, H
  holds f is Homomorphism of G1, G2
proof
  let G1, G2 be Group;
  let H be Subgroup of G2;
  let f be Homomorphism of G1, H;
  A1: dom f = the carrier of G1 by FUNCT_2:def 1;
  rng f c= the carrier of H
         & the carrier of H c= the carrier of G2
  by FUNCT_5:11, GROUP_2:def 5;
  then A2: f is Function of G1, G2 by A1, FUNCT_2:2, XBOOLE_1:1;
  f is multiplicative Function of G1, G2
  proof
    reconsider ff=f as Function of G1,G2 by A2;
    for g1,g2 being Element of G1
    holds ff.(g1*g2) = (ff.g1) * (ff.g2)
    proof
      let g1,g2 be Element of G1;
      thus (ff.g1)*(ff.g2) = (f.g1) * (f.g2) by GROUP_2:43
                          .= f.(g1 * g2) by GROUP_6:def 6
                          .= ff.(g1 * g2);
    end;
    hence thesis by GROUP_6:def 6;
  end;
  hence f is Homomorphism of G1, G2;
end;

begin :: Universal Property of Quotient Group
theorem Th22:
  for G being Group
  for N being normal Subgroup of G
  for a,b being Element of G
  st a*N = b*N
  ex n being Element of G st n in N & a*n=b
proof
  let G be Group;
  let N be normal Subgroup of G;
  let a,b be Element of G;
  assume A1: a*N = b*N;
  consider n being Element of G such that
  A2: n = a" * b;
  take n;
  thus n in N by A1, A2, GROUP_2:114;
  a * n = (a * a") * b by A2, GROUP_1:def 3
       .= (1_G) * b by GROUP_1:def 5
       .= b by GROUP_1:def 4;
  hence thesis;
end;

theorem
  for G being Group
  for N being normal Subgroup of G
  for H being Group
  for phi being Homomorphism of G,H st N is Subgroup of Ker phi
  ex f being Homomorphism of (G./.N), H
  st phi = f * (nat_hom N)
proof
  let G be Group;
  let N be normal Subgroup of G;
  let H be Group;
  let phi be Homomorphism of G,H;
  assume A1: N is Subgroup of Ker phi;
  defpred P[object, object] means
  ex g being Element of G st $1 = g*N & $2 = (phi.g);
  A2: for x being object st x in the carrier of G./.N
  ex y being object st y in the carrier of H & P[x,y]
  proof
    let x be object;
    assume x in the carrier of G./.N;
    then x in G./.N;
    then consider g being Element of G such that
    B1: x = g*N & x = N*g by GROUP_6:23;
    take y = phi.g;
    thus y in the carrier of H;
    take g;
    thus x = g*N by B1;
    thus y = phi.g;
  end;
  consider f being Function of the carrier of (G./.N), the carrier of H
  such that
  A3: for x being object st x in the carrier of G./.N holds P[x, f.x]
  from FUNCT_2:sch 1(A2);
  reconsider f as Function of G./.N, H;

  A4: for x being Element of G./.N
  ex g being Element of G
  st f.x = phi.g & x = g*N
  proof
    let x be Element of G./.N;
    P[x, f.x] by A3;
    hence thesis;
  end;
  A5: for x being Element of G./.N
  for g being Element of G st x = g*N
  holds f.(g * N) = phi.g
  proof
    let x be Element of G./.N;
    let g be Element of G;
    assume B1: x = g*N;
    consider g0 being Element of G such that
    B2: f.x = phi.g0 & x = g0*N by A4;
    consider n being Element of G such that
    B3: n in N & g0*n = g
    by B1, B2, Th22;
    
    phi.g = (phi.g0) * (phi.n) by B3, GROUP_6:def 6
    .= (phi.g0) * (1_H) by A1, B3, GROUP_2:40, GROUP_6:41
    .= phi.g0 by GROUP_1:def 4;
    hence f.(g * N) = phi.g by B1, B2;
  end;

  for a, b being Element of G./.N
  holds f.(a * b) = (f.a) * (f.b)
  proof
    let a, b be Element of G./.N;
    consider ga being Element of G such that
    B1: f.a = phi.ga and
    B2: a = ga*N by A4;
    consider gb being Element of G such that
    B3: f.b = phi.gb and
    B4: b = gb*N by A4;
    
    (ga * N) * (gb * N)
    = ((ga * 1_G) * N) * (gb * N) by GROUP_1:def 4
    .= ((ga * (gb * gb")) * N) * (gb * N) by GROUP_1:def 5
    .= (((ga * gb) * gb") * N) * (gb * N) by GROUP_1:def 3
    .= ((ga * gb) * (gb" * N)) * (gb * N) by GROUP_2:105
    .= ((ga * gb) * (N * gb")) * (gb * N) by GROUP_3:117
    .= (((ga * gb) * (N * gb")) * gb) * N by GROUP_3:9
    .= ((ga * gb) * ((N * gb") * gb)) * N by GROUP_2:10
    .= ((ga * gb) * (N * (gb" * gb))) * N by GROUP_2:34
    .= ((ga * gb) * (N * (1_G))) * N by GROUP_1:def 5
    .= ((ga * gb) * N) * N by GROUP_2:109
    .= (ga * gb) * (N * N) by GROUP_2:29
    .= (ga * gb) * N by GROUP_2:76;
    then B7: (ga * gb) * N = (@ a) * (@ b) by B2,B4, GROUP_6:def 5
::>                                         *4
    .= (a * b) by GROUP_6:19;
    (f.a) * (f.b) = phi.(ga * gb) by B1, B3, GROUP_6:def 6
    .= f.(a * b) by B7, A5;
    
    hence f.(a * b) = (f.a) * (f.b);
  end;
  then reconsider f as Homomorphism of G./.N, H by GROUP_6:def 6;
  take f;
  
  for g being Element of G
  holds phi.g = (f * (nat_hom N)).g
  proof
    let g be Element of G;
    reconsider x = (nat_hom N).g as Element of G./.N;
    B1: x = g * N by GROUP_6:def 8;
    (f * (nat_hom N)).g = f.((nat_hom N).g) by FUNCT_2:15
                       .= phi.g by B1, A5;
    hence phi.g = (f * (nat_hom N)).g;
  end;
  hence phi = f * (nat_hom N);
end;

begin :: Families of Homomorphisms
definition
  let G be Group;
  let I be non empty set;
  let F be Group-Family of I;
  mode Homomorphism-Family of G, F -> ManySortedFunction of I means
  :Def13:
  for i being Element of I holds
  it.i is Homomorphism of G, F.i;
  existence
  proof
    deffunc F1() = I;
    deffunc F2(Element of I) = 1:(G, F.$1);
    consider f being ManySortedSet of F1() such that
    A1: for i being Element of F1() holds f.i = F2(i)
    from PBOOLE:sch 5;
    for x being object st x in dom f holds f.x is Function
    proof
      let x be object;
      assume x in dom f;
      then reconsider i=x as Element of I;
      f.i = 1:(G,F.i) by A1;
      hence f.x is Function;
    end;
    then reconsider f as ManySortedFunction of I by FUNCOP_1:def 6;
    take f;
    thus for i being Element of I holds f.i is Homomorphism of G, F.i
    proof
      let i be Element of I;
      f.i = 1:(G, F.i) by A1;
      hence f.i is Homomorphism of G, F.i;
    end;
  end;
end;

:: I hate this, but have no better alternative
definition
  let G be Group;
  let I be non empty set;
  let F be Group-Family of I;
  let f be Homomorphism-Family of G, F;
  let i be Element of I;
  redefine func f.i -> Homomorphism of G, F.i;
  coherence by Def13;
end;

reserve f for Homomorphism-Family of G, F;

theorem Th20:
  (Carrier F).i = the carrier of F.i
proof
  ex R being 1-sorted
  st (R = (F.i) & (Carrier F).i = the carrier of R) by PRALG_1:def 15;
  hence (Carrier F).i = the carrier of F.i;
end;

theorem
  [i, f.i] in f
proof
  i in I & f is ManySortedSet of I;
  then i in dom f by PARTFUN1:def 2;
  hence [i, f.i] in f by FUNCT_1:def 2;
end;

theorem
  for X,Y being non empty set
  for f being Function of X,Y
  st f is onto
  ex g being Function of Y,X
  st f * g = id Y
proof
  let X,Y be non empty set;
  let f be Function of X,Y;
  assume A1: f is onto;
  defpred P[object, object] means $1 = f.$2;
  A2: for y being object st y in Y
  ex x being object st x in X & P[y, x]
  proof
    let y be object;
    assume y in Y;
    then reconsider yy=y as Element of Y;
    consider x being Element of X such that
    B1: f.x = yy
    by A1, GROUP_6:58;
    take x;
    thus x in X;
    thus P[y, x] by B1;
  end;

  consider g being Function of Y,X such that
  A3: for y being object st y in Y holds P[y, g.y]
  from FUNCT_2:sch 1(A2);
  take g;
  for y being Element of Y holds (f * g).y = y
  proof
    let y be Element of Y;
    B1: dom g = Y & dom (f * g) = dom g by FUNCT_2:123, FUNCT_2:def 1;
    y = f.(g.y) by A3
     .= (f * g).y by B1, FUNCT_1:12;
    hence (f * g).y = y;
  end;
  hence f * g = id Y;
end;

:: This probably belongs in PBOOLE
definition
  let I be non empty set;
  let A, B be ManySortedSet of I;
  let f be ManySortedFunction of A,B;
  let i be Element of I;
  redefine func f.i -> Function of A.i, B.i;
  coherence by PBOOLE:def 15;
end;

:: This probably belongs in PRALG_1
definition
  let I be non empty set;
  let F1,F2 be 1-sorted-yielding ManySortedSet of I;
  mode ManySortedFunction of F1,F2
  is ManySortedFunction of (Carrier F1),(Carrier F2);
end;

:: This probably belongs in PRALG_1
definition
  let I be non empty set;
  let F1,F2 be 1-sorted-yielding ManySortedSet of I;
  let phi be ManySortedFunction of F1,F2;
  let i be Element of I;
  redefine func phi.i -> Function of the carrier of F1.i, the carrier of F2.i;
  correctness
  proof
    A1: ex R being 1-sorted
    st (R = F1.i & (Carrier F1).i = the carrier of R) by PRALG_1:def 15;
    ex R2 being 1-sorted
    st (R2 = F2.i & (Carrier F2).i = the carrier of R2)
    by PRALG_1:def 15;
    hence thesis by A1, PBOOLE:def 15;
  end;
end;

theorem Th23:
  for I being non empty set
  for A, B being ManySortedSet of I
  for f being ManySortedSet of I
  holds f is ManySortedFunction of A,B
  iff (for i being Element of I holds f.i is Function of A.i, B.i)
proof
  let I be non empty set;
  let A, B be ManySortedSet of I;
  let f be ManySortedSet of I;
  thus f is ManySortedFunction of A,B
  implies (for i being Element of I holds f.i is Function of A.i, B.i)
  by PBOOLE:def 15;
  assume for i being Element of I holds f.i is Function of A.i, B.i;
  then for i being object st i in I holds
  f.i is Function of (A.i), (B.i);
  hence f is ManySortedFunction of A,B by PBOOLE:def 15;
end;

definition
  let I be non empty set;
  let F1,F2 be Group-Family of I;
  mode Homomorphism-Family of F1,F2 -> ManySortedFunction of F1,F2 means
  :Def14:
  for i being Element of I
  holds it.i is Homomorphism of F1.i,F2.i;
  existence
  proof
    deffunc Fun(Element of I) = 1:(F1.$1, F2.$1);
    consider phi being ManySortedSet of I such that
    A1: for i being Element of I holds phi.i = Fun(i)
    from PBOOLE:sch 5;
    A2: for i being Element of I holds phi.i is Homomorphism of F1.i,F2.i
    proof
      let i be Element of I;
      phi.i = 1:(F1.i, F2.i) by A1;
      hence phi.i is Homomorphism of F1.i,F2.i;
    end;
    for i being Element of I
    holds phi.i is Function of (Carrier F1).i, (Carrier F2).i
    proof
      let i be Element of I;
      the carrier of F1.i = (Carrier F1).i
      & the carrier of F2.i = (Carrier F2).i by Th20;
      hence phi.i is Function of (Carrier F1).i, (Carrier F2).i by A2;
    end;
    then reconsider phi as ManySortedFunction of F1,F2 by Th23;
    take phi;
    
    thus thesis by A2;
  end;
end;

registration
  let I be non empty set;
  let F1,F2 be Group-Family of I;
  let i be Element of I;
  let phi be Homomorphism-Family of F1,F2;
  cluster (phi . i) -> multiplicative for Function of F1.i, F2.i;
  correctness by Def14;
end;

theorem ThHom:
  for I being non empty set
  for A, B being Group-Family of I
  for f being ManySortedSet of I
  holds f is Homomorphism-Family of A,B
  iff (for i being Element of I holds f.i is Homomorphism of A.i, B.i)
proof
  let I be non empty set;
  let A, B be Group-Family of I;
  let f be ManySortedSet of I;
  thus f is Homomorphism-Family of A,B
  implies (for i being Element of I holds f.i is Homomorphism of A.i, B.i)
  proof
    assume A1: f is Homomorphism-Family of A,B;
    let i be Element of I;
    reconsider ff=f as Homomorphism-Family of A,B by A1;
    ff.i = f.i & ff.i is Homomorphism of A.i, B.i by A1;
    hence thesis;
  end;
  thus (for i being Element of I holds f.i is Homomorphism of A.i, B.i)
  implies f is Homomorphism-Family of A, B
  proof
    assume A1: for i being Element of I holds f.i is Homomorphism of A.i, B.i;
    for i being object st i in I holds f.i is Function of (Carrier A).i,
    (Carrier B).i
    proof
      let i be object;
      assume B1: i in I;
      then reconsider ii=i as Element of I;
      f.ii is Homomorphism of A.ii, B.ii by A1;
      then B2: f.i is Homomorphism of A.ii, B.ii;
      (Carrier A).i = the carrier of A.ii &
      (Carrier B).i = the carrier of B.ii by ThCarr;
      hence f.i is Function of (Carrier A).i, (Carrier B).i by B2;
    end;
    then f is ManySortedFunction of (Carrier A), (Carrier B) by PBOOLE:def 15;
    hence thesis by A1, Def14;
  end;
end;

scheme
HomFamSch { I1() -> non empty set,
            Dom() -> Group-Family of I1(),
            Cod() -> Group-Family of I1(),
            Fun(Element of I1()) -> Function } :
  ex H being Homomorphism-Family of Dom(), Cod()
  st for i being Element of I1() holds H.i = Fun(i)
provided
A1: for i being Element of I1()
    holds Fun(i) is Homomorphism of Dom().i, Cod().i
proof
  consider H being ManySortedSet of I1() such that
  A2: for i being Element of I1() holds H.i = Fun(i)
  from PBOOLE:sch 5;
  for i being Element of I1()
  holds H.i is Homomorphism of Dom().i, Cod().i
  proof
    let i be Element of I1();
    H.i = Fun(i) by A2;
    hence H.i is Homomorphism of Dom().i, Cod().i by A1;
  end;
  then A3: H is Homomorphism-Family of Dom(), Cod() by ThHom;
  then reconsider H as Homomorphism-Family of Dom(), Cod();
  take H;
  thus thesis by A2;
end;

theorem ThRHom:
  for G being Group
  for I being non empty set
  for F being Group-Family of I
  for f being ManySortedSet of I
  holds f is Homomorphism-Family of G,F
  iff (for i being Element of I holds f.i is Homomorphism of G, F.i)
proof
  let G be Group;
  let I be non empty set;
  let F be Group-Family of I;
  let f be ManySortedSet of I;

  thus f is Homomorphism-Family of G,F
  implies (for i being Element of I holds f.i is Homomorphism of G, F.i)
  proof
    assume A1: f is Homomorphism-Family of G,F;
    let i be Element of I;
    thus f.i is Homomorphism of G, F.i by A1, Def13;
  end;
  assume A2: for i being Element of I
  holds f.i is Homomorphism of G, F.i;
  for i being object st i in dom f holds f.i is Function
  proof
    let i be object;
    assume B1: i in dom f;
    then reconsider ii=i as Element of I;
    f.ii is Homomorphism of G, F.ii by A2;
    hence thesis;
  end;
  then f is Function-yielding by FUNCOP_1:def 6;
  then f is ManySortedFunction of I;
  hence f is Homomorphism-Family of G,F by A2, Def13;
end;

scheme
RHomFamSch { I1() -> non empty set,
             Dom() -> Group,
             Cod() -> Group-Family of I1(),
             Fun(Element of I1()) -> Function } :
  ex H being Homomorphism-Family of Dom(), Cod()
  st for i being Element of I1() holds H.i = Fun(i)
provided
A1: for i being Element of I1()
    holds Fun(i) is Homomorphism of Dom(), Cod().i
proof
  consider H being ManySortedSet of I1() such that
  A2: for i being Element of I1() holds H.i = Fun(i)
  from PBOOLE:sch 5;
  for i being Element of I1()
  holds H.i is Homomorphism of Dom(), Cod().i
  proof
    let i be Element of I1();
    H.i = Fun(i) by A2;
    hence H.i is Homomorphism of Dom(), Cod().i by A1;
  end;
  then A3: H is Homomorphism-Family of Dom(), Cod() by ThRHom;
  then reconsider H as Homomorphism-Family of Dom(), Cod();
  take H;
  thus thesis by A2;
end;

theorem ThHom:
  for I being non empty set
  for A, B being Group-Family of I
  for f being ManySortedSet of I
  holds f is Homomorphism-Family of A,B
  iff (for i being Element of I holds f.i is Homomorphism of A.i, B.i)
proof
  let I be non empty set;
  let A, B be Group-Family of I;
  let f be ManySortedSet of I;
  thus f is Homomorphism-Family of A,B
  implies (for i being Element of I holds f.i is Homomorphism of A.i, B.i)
  proof
    assume A1: f is Homomorphism-Family of A,B;
    let i be Element of I;
    reconsider ff=f as Homomorphism-Family of A,B by A1;
    ff.i = f.i & ff.i is Homomorphism of A.i, B.i by A1;
    hence thesis;
  end;
  thus (for i being Element of I holds f.i is Homomorphism of A.i, B.i)
  implies f is Homomorphism-Family of A, B
  proof
    assume A1: for i being Element of I holds f.i is Homomorphism of A.i, B.i;
    for i being object st i in I holds f.i is Function of (Carrier A).i,
    (Carrier B).i
    proof
      let i be object;
      assume B1: i in I;
      then reconsider ii=i as Element of I;
      f.ii is Homomorphism of A.ii, B.ii by A1;
      then B2: f.i is Homomorphism of A.ii, B.ii;
      (Carrier A).i = the carrier of A.ii &
      (Carrier B).i = the carrier of B.ii by ThCarr;
      hence f.i is Function of (Carrier A).i, (Carrier B).i by B2;
    end;
    then f is ManySortedFunction of (Carrier A), (Carrier B) by PBOOLE:def 15;
    hence thesis by A1, Def14;
  end;
end;

begin :: Projection Morphisms from Product Group to Direct Factors
theorem Th35:
  for g being Element of product F
  holds g.i is Element of F.i
proof
  let g be Element of product F;
  g is Function & g in product F;
  then g.i in F.i by GROUP_19:5;
  hence thesis;
end;

definition
  let I be non empty set;
  let F be Group-Family of I;
  let g be Element of product F;
  let i be Element of I;
  func g/.i -> Element of F.i equals :Def15: g.i;
  correctness by Th35;
end;

registration
  let I be non empty set;
  let F be Group-Family of I;
  let g be Element of product F;
  let i be Element of I;
  identify g/.i with g.i;
  correctness;
end;

definition
  let I be non empty set;
  let i be Element of I;
  let F be Group-Family of I;
  func proj (F, i) -> Homomorphism of (product F), F.i means
  :Def16:
  for h being Element of product F holds it.h = h.i;
  existence
  proof
    deffunc F1() = product F;
    deffunc F2() = F.i;
    deffunc F3(Element of F1()) = $1/.i;
    consider p being Function of F1(), F2() such that
    A1: for x being Element of F1() holds p.x = F3(x)
    from FUNCT_2:sch 4;
    reconsider p as Function of product F, F.i;
    
    for a, b being Element of product F
    holds p.(a * b) = (p.a) * (p.b)
    proof
      let a, b be Element of product F;
      (p.a) * (p.b) = (p.a) * (b/.i) by A1
                   .= (a/.i) * (b/.i) by A1
                   .= (a * b)/.i by GROUP_7:1
                   .= p.(a * b) by A1;
      hence p.(a * b) = (p.a) * (p.b);
    end;
    then reconsider p as Homomorphism of product F,F.i by GROUP_6:def 6;
    take p;
    for h being Element of product F holds p.h = h.i
    proof
      let h be Element of product F;
      p.h = h/.i by A1;
      hence thesis;
    end;
    hence thesis;
  end;
  uniqueness
  proof
    let p1,p2 be Homomorphism of (product F), F.i;
    assume A1: for h being Element of product F holds p1.h = h.i;
    assume A2: for h being Element of product F holds p2.h = h.i;
    for x being object st x in the carrier of product F holds p1.x = p2.x
    proof
      let x be object;
      assume x in the carrier of product F;
      then reconsider xx=x as Element of product F;
      p1.x = xx.i by A1;
      hence p1.x = p2.x by A2;
    end;
    hence p1 = p2;
  end;
end;

theorem
  proj (F, i) is onto
proof
  for y being object
  holds y in the carrier of F.i iff
  ex x being object st x in dom (proj (F,i)) & y = (proj (F,i)).x
  proof
    let y be object;
    thus y in the carrier of F.i
         implies ex x being object
                 st x in dom (proj (F,i))
                    & y = (proj (F,i)).x
    proof 
      assume y in the carrier of F.i;
      then reconsider yy=y as Element of F.i;
      (1ProdHom (F, i)).yy in ProjGroup (F, i);
      then (1ProdHom (F, i)).yy in ProjSet (F, i) by GROUP_12:def 2;
      then consider x being Function, g being Element of F.i such that
      A1: x = (1ProdHom (F, i)).yy & dom x = I & x.i = g &
          for j being Element of I st j <> i holds x.j = 1_(F.j)
      by GROUP_12:2;
      
      the carrier of (product F) = product (Carrier F) by GROUP_7:def 2;
      then dom (1_(product F)) = I by PARTFUN1:def 2;
      then A2: y = ((1_(product F)) +* (i, y)).i by FUNCT_7:31
                .= g by A1, GROUP_12:def 3;
      A3: x in product F by A1,GROUP_2:41;
      take x;
      thus x in dom (proj (F,i)) by A3, FUNCT_2:def 1;
      thus y = (proj (F,i)).x by Def16, A1, A2, A3;
    end;
    thus (ex x being object
          st x in dom (proj (F,i)) & y = (proj (F,i)).x)
         implies y in the carrier of F.i by FUNCT_2:5;
  end;
  hence proj (F, i) is onto by FUNCT_1:def 3;
end;

theorem Th37:
  proj (Carrier F, i) is Function of product (Carrier F), the carrier of F.i
proof
  set X = product (Carrier F);
  set Y = the carrier of F.i;
  set f = proj (Carrier F, i);
  A1: dom f = X by CARD_3:def 16;
  for x being object st x in X holds f.x in Y
  proof
    let x be object;
    assume A2: x in X;
    then reconsider y=x as Element of product F by GROUP_7:def 2;
    f.y = y/.i by A1, A2, CARD_3:def 16;
    hence f.x in Y;
  end;
  
  hence f is Function of X,Y by A1, FUNCT_2:3;
end;

theorem Th38:
  for g being Element of product F
  holds proj (F, i) . g = proj (Carrier F, i) . g 
proof
  let g be Element of product F;
  set X = product (Carrier F);
  set f = proj (Carrier F, i);
  A1: dom f = X by CARD_3:def 16;
  g in product F;
  then g in dom f by A1, GROUP_7:def 2;
  then (proj (Carrier F, i)) . g = g.i by CARD_3:def 16;
  hence (proj (F, i)) . g = (proj (Carrier F, i)) . g by Def16;
end;

theorem
  proj (F, i) = proj (Carrier F, i)
proof
  set X = product (Carrier F);
  set Y = the carrier of F.i;
  product (Carrier F) = the carrier of (product F) by GROUP_7:def 2;
  then A1: proj (Carrier F, i) is Function of X,Y
           & proj (F, i) is Function of X,Y
  by Th37;
  for x being Element of X
  holds (proj (F, i)) . x = (proj (Carrier F, i)) . x
  proof
    let x be Element of X;
    x is Element of product F by GROUP_7:def 2;
    hence thesis by Th38;
  end;
  hence thesis by A1, FUNCT_2:63;
end;

theorem Th40:
  for g being Element of product F
  for h being Element of F.i
  holds g +* (i, h) in product F
proof
  let g be Element of product F;
  let h be Element of F.i;
  A1: dom g = I by GROUP_19:3;
  then dom (g +* (i, h)) = I by FUNCT_7:30;
  then A2: dom (g +* (i, h)) = dom (Carrier F) by PARTFUN1:def 2;
  for j being object st j in dom (Carrier F)
  holds (g +* (i, h)).j in (Carrier F).j
  proof
    let j be object;
    assume j in dom (Carrier F);
    then reconsider ii=j as Element of I;
    B1: ex R being 1-sorted
    st (R = F.ii & (Carrier F).ii = the carrier of R)
    by PRALG_1:def 15;
    per cases;
    suppose B2: i = j;
      then (g +* (i, h)).i = (g +* (j, h)).j
      .= (g +* (ii, h)).ii
      .= h by A1, FUNCT_7:31;
      hence thesis by B1, B2;
    end;
    suppose B3: i <> j;
      g in product F;
      then g.ii in F.ii by GROUP_19:5;
      hence thesis by B1, B3, FUNCT_7:32;
    end;
  end;

  then (g +* (i, h)) in product (Carrier F) by A2, CARD_3:def 5;
  hence (g +* (i, h)) in product F by GROUP_7:def 2;
end;

theorem
  for i being Element of I
  for g being Element of product F
  holds (g +* (i, 1_(F.i))) in Ker (proj (F, i)) 
proof
  let i be Element of I;
  let g be Element of product F;
  A1: dom g = I by GROUP_19:3;
  (g +* (i, 1_(F.i))) in product F by Th40;
  then reconsider h=(g +* (i, 1_(F.i))) as Element of product F;
  (proj (F, i)).h = h.i by Def16
                 .= 1_(F.i) by A1, FUNCT_7:31;
  hence (g +* (i, 1_(F.i))) in Ker (proj (F, i)) by GROUP_6:41;
end;

LmProdhom:
  1ProdHom (F, i) is Homomorphism of F.i, product F
proof
  (ProjGroup (F,i)) is Subgroup of product F &
  1ProdHom (F, i) is Homomorphism of F.i, ProjGroup (F, i);
  hence thesis by Th25;
end;

LmRangeContainedInCod:
  for X,Y being set
  for f being Function of X,Y
  holds rng f c= Y
proof
  let X,Y be set;
  let f be Function of X,Y;
  per cases;
  suppose A1: Y <> {};
    for y being object st y in rng f holds y in Y
    proof
      let y be object;
      assume B1: y in rng f;
      then consider x being object such that
      B2: x in dom f and
      B3: y = f.x
      by FUNCT_1:def 3;
      x in X by A1, B2, FUNCT_2:def 1;
      hence y in Y by A1,B2,B3,FUNCT_2:5;
    end;
    hence rng f c= Y;
  end;
  suppose A2: Y = {};
    for y being object st y in rng f holds y in Y
    proof
      let y be object;
      assume B1: y in rng f;
      dom f = {} by A2, FUNCT_2:def 1;
      then not (ex x being object st x in dom f & y = f.x);
      then not (y in rng f) by FUNCT_1:def 3;
      then contradiction by B1;
      hence y in Y;
    end;
    hence rng f c= Y;
  end;
end;

LmEqRng:
  for X,Y,Z,W being set st Z <> {} & W <> {}
  for f being Function of [:X,Y:],Z
  for g being Function of [:X,Y:],W
  st (for a being Element of X, b being Element of Y holds f.(a,b) = g.(a,b))
  holds rng f = rng g
proof
  let X,Y,Z,W be set;
  assume A0: Z <> {} & W <> {};
  let f be Function of [:X,Y:],Z;
  let g be Function of [:X,Y:],W;
  assume A1: for a being Element of X, b being Element of Y
  holds f.(a,b) = g.(a,b);
  A2: dom f = [:X,Y:] by A0, FUNCT_2:def 1;
  A3: dom g = [:X,Y:] by A0, FUNCT_2:def 1;
  A4: dom f = dom g by A2,A3;
  for z being object holds z in rng f iff z in rng g
  proof
    let z be object;
    thus z in rng f implies z in rng g
    proof
      assume B1: z in rng f;
      then consider x being object such that
      B2: x in dom f and
      B3: z = f.x
      by FUNCT_1:def 3;
      consider a,b being object such that
      B4: a in X and
      B5: b in Y and
      B6: [a, b] = x
      by A2, B2, ZFMISC_1:def 2;
      B7: g.([a,b]) = g.x by B6,BINOP_1:def 1;
      B8: x in dom g by A4, B2;
      reconsider a as Element of X by B4;
      reconsider b as Element of Y by B5;
      f.x = f.([a, b]) by B6
      .= f.(a, b)
      .= g.(a, b) by A1
      .= g.x by B7;
      hence z in rng g by B3,B8,FUNCT_1:3;
    end;
    thus z in rng g implies z in rng f
    proof
      assume B1: z in rng g;
      then consider x being object such that
      B2: x in dom g and
      B3: z = g.x
      by FUNCT_1:def 3;
      consider a,b being object such that
      B4: a in X and
      B5: b in Y and
      B6: [a, b] = x
      by A3, B2, ZFMISC_1:def 2;
      B7: f.([a,b]) = f.x by B6,BINOP_1:def 1;
      B8: x in dom f by A4, B2;
      then B9: f.x in rng f by FUNCT_1:3;
      reconsider a as Element of X by B4;
      reconsider b as Element of Y by B5;
      B8: x in [:X,Y:] by B2,A3;
      g.x = g.([a, b]) by B6
      .= g.(a, b)
      .= f.(a, b) by A1
      .= f.x by B7;
      then f.x = z by B3;
      hence z in rng f by B9;
    end;
  end;

  hence rng f = rng g by TARSKI:2;
end;

theorem InclByAnyOtherName:
  for G1,G2 being Group
  for f being Homomorphism of G1, G2
  st (for g being Element of G1 holds f.g = g)
  holds G1 is Subgroup of G2
proof
  let G1,G2 be Group;
  let f be Homomorphism of G1, G2;
  assume A1: for g being Element of G1 holds f.g = g;

  A2: the carrier of G1 c= the carrier of G2
  proof
    for g being Element of the carrier of G1
    holds g in the carrier of G2
    proof
      let g be Element of the carrier of G1;
      (f.g) in the carrier of G2;
      hence g in the carrier of G2 by A1;
    end;
    hence thesis;
  end;
  then reconsider U=the carrier of G1 as Subset of the carrier of G2;
  set U1 = the carrier of G1;
  set U2 = the carrier of G2;
  A2a: U1 <> {};
  A2b: U2 <> {};
  A3: [: U1, U1 :] c= [: U2, U2 :] by A2, ZFMISC_1:96;
  A4: dom (the multF of G2) = [: U2, U2 :]
  by FUNCT_2:def 1;
  then A5: dom ((the multF of G2)|[: U1, U1 :]) = [: U1, U1 :]
  by A3, RELAT_1:62;
  A5a: dom ((the multF of G2)||U1)
   = dom ((the multF of G2)|[: U1, U1 :]) by REALSET1:def 2
  .= [: U1, U1 :] by A5;
  A5b: ((the multF of G2)||U1)
  = ((the multF of G2)|[: U1, U1 :]) by REALSET1:def 2;
  A6: for a being Element of U1
  for b being Element of U1
  holds (the multF of G1).(a, b) = ((the multF of G2)||U1).(a, b)
  proof
    let a be Element of U1;
    let b be Element of U1;
    a in U1 & b in U1;
    then [a, b] in [: U1, U1 :] by ZFMISC_1:87;
    then [a, b] in dom ((the multF of G2)||U1) by A5a;
    then B1: [a, b] in dom ((the multF of G2)|[: U1, U1 :]) by REALSET1:def 2;
    then B2:
    (the multF of G2).([a, b])
     = ((the multF of G2)|[: U1, U1 :]).([a, b]) by B1, A5a, FUNCT_1:47
    .= ((the multF of G2)||U1).(a, b) by  REALSET1:def 2;
    set c = a * b;
    B3: c = (the multF of G1).(a, b) by ALGSTR_0:def 18;
    B4: (the multF of G2).(f.a, f.b)
      = (the multF of G2).(f.a, b) by A1
     .= (the multF of G2).(a, b) by A1;
    c = f.c by A1
     .= (f.a) * (f.b) by GROUP_6:def 6
     .= (the multF of G2).(f.a, f.b) by ALGSTR_0:def 18
     .= (the multF of G2).(a, b) by B4;
    hence (the multF of G1).(a, b) = ((the multF of G2)||U1).(a, b)
    by B2, B3;
  end;
  ((the multF of G2)||U1) is BinOp of U1
  proof
    B0: (the multF of G1) is Function of [: U1, U1 :], U1;
    then B1: rng (the multF of G1) c= U1 by LmRangeContainedInCod;
    :: (the multF of G2)||U1 = (the multF of G2)|[:U1,U1:];
    U1 c= U2 & U2 = {} implies U1 = {} by A2;
    then B2a: ((the multF of G2)||U1) is Function of [:U1,U1:], U2
    by A3, A5b, FUNCT_2:32;
    
    ((the multF of G2)||U1) is Function of dom ((the multF of
    G2)||U1), rng ((the multF of G2)||U1) by FUNCT_2:1;
    then B2: ((the multF of G2)||U1) is Function of [: U1, U1 :],
    rng ((the multF of G2)||U1) by A5a;
    then
    rng ((the multF of G2)||U1) = rng (the multF of G1)
    by A2a, A2b, A6, B0, B2a, LmEqRng;
    then B3: rng ((the multF of G2)||U1) c= U1 by B1;

    ([: U1, U1 :] <> {} implies (rng ((the multF of G2)||U1)) <> {})
    proof
      assume C1: [: U1, U1 :] <> {};
      then [: U1, U1 :] is non empty;
      then consider x being object such that
      C2: x in [: U1, U1 :]
      by XBOOLE_0:def 1;
      x in dom ((the multF of G2)||U1) by C2, A5a;
      then ((the multF of G2)||U1).x in rng (((the multF of G2)||U1))
      by FUNCT_1:3;
      hence (rng ((the multF of G2)||U1)) <> {};
    end;
    then ((rng ((the multF of G2)||U1)) = {} implies [: U1, U1 :] = {});
    then ((the multF of G2)||U1) is Function of [: U1, U1 :], U1
    by B2, B3, FUNCT_2:6;
    hence thesis by FUNCT_2:6;
  end;
  then the multF of G1 = (the multF of G2)||U1 by A6, BINOP_1:2;
  hence G1 is Subgroup of G2 by A2, GROUP_2:def 5;
end;

theorem Th65:
  (proj (F,i)) * (1ProdHom (F, i)) = id (the carrier of F.i)
proof
  set U = the carrier of F.i;
  (1ProdHom (F, i)) is Homomorphism of F.i, product F by Th25;
  then A1: ((proj (F,i)) * (1ProdHom (F, i))) is Function of U, U;

  for x being Element of U
  holds ((proj (F,i)) * (1ProdHom (F, i))).x = x
  proof
    let x be Element of U;
    B1: dom (1_(product F)) = I by GROUP_19:3;
    B2: (1ProdHom (F, i)).x = (1_(product F)) +* (i, x) by GROUP_12:def 3;
    (1ProdHom (F, i)).x in (ProjGroup (F,i));
    then (1ProdHom (F, i)).x in product F by GROUP_2:40;
    then B3: (proj (F, i)).((1_(product F)) +* (i, x))
    = ((1_(product F)) +* (i, x)).i by B2, Def16;
    dom (1ProdHom (F, i)) = U by FUNCT_2:def 1;
    then ((proj (F,i)) * (1ProdHom (F, i))).x
     = (proj (F, i)).((1ProdHom (F, i)).x) by FUNCT_1:13
    .= (proj (F, i)).((1_(product F)) +* (i, x)) by GROUP_12:def 3
    .= x by B1, B3, FUNCT_7:31;
    hence thesis;
  end;

  hence thesis by A1, FUNCT_2:124;
end;

begin :: Universal Property of Direct Products of Groups
:: Universal property of group product, explicit version.
theorem Th42:
  for f being Homomorphism-Family of G, F
  ex phi being Homomorphism of G, product F
  st for g being Element of G
     holds (for j being Element of I holds (f.j).g = (proj (F,j)) . (phi.g))
proof
  let f be Homomorphism-Family of G, F;
  defpred P[object, object] means ex g0 being Element of product F
  st $2 = g0 & (for j being Element of I holds (f.j).$1 = g0.j);
  deffunc F1() = the carrier of G;

  A1: for x being object st x in F1()
  ex y being object st y in the carrier of product F &
  P[x,y]
  proof
    let x be object;
    assume x in F1();
    then reconsider xx=x as Element of G;
    defpred P1[object, object] means ex i being Element of I st
    i = $1 & $2 = ((f.i).xx);
    B1: for i, y1, y2 being object st i in I & P1[i,y1] & P1[i,y2]
        holds y1 = y2;
    B2: for i being object st i in I holds ex y being object st P1[i,y]
    proof
      let i be object;
      assume i in I;
      then reconsider ii=i as Element of I;
      consider y being object such that
      C1: y = ((f.ii).xx);
      take y;
      thus P1[i,y] by C1;
    end;
    
    consider y being Function such that
    B3: dom y = I and
    B4: for j being object st j in I holds P1[j, y.j]
    from FUNCT_1:sch 2(B1, B2);
    take y;
    thus y in the carrier of product F
    proof
      C1: dom y = dom (Carrier F) by B3, PARTFUN1:def 2;
      for i being Element of I holds y.i in (Carrier F).i
      proof
        let i be Element of I;
        P1[i, y.i] by B4;
        then consider ii being Element of I such that
        D1: ii=i & y.i = ((f.i).xx);
        (Carrier F).i = the carrier of F.i by Th20; 
        hence thesis by D1;
      end;
      then for i being object st i in dom (Carrier F)
           holds y.i in (Carrier F).i;
      then y in product (Carrier F) by C1, CARD_3:9;
      hence thesis by GROUP_7:def 2;
    end;
    then consider g0 being Element of product F such that
    B5: g0 = y;
    take g0;
    thus y = g0 by B5;
    let j be Element of I;
    P1[j, g0.j] by B4, B5;
    hence (f.j).x = g0.j;
  end;

  consider phi being Function of F1(), the carrier of (product F)
  such that
  A2: for x being object st x in F1() holds P[x, phi.x]
  from FUNCT_2:sch 1(A1);
  reconsider phi as Function of G, product F;

  A3: for g being Element of G
  for j being Element of I
  holds (phi.g).j = (f.j).g
  proof
    let g be Element of G;
    let j be Element of I;
    P[g, phi.g] by A2;
    hence (phi.g).j = (f.j).g;
  end;

  for a, b being Element of G holds phi.(a * b) = (phi.a) * (phi.b)
  proof
    let a, b be Element of G;
    (phi.(a * b)) is Element of product (Carrier F)
    & (phi.a)*(phi.b) is Element of product (Carrier F)
    by GROUP_7:def 2;
    then B1: dom (phi.(a * b)) = I & dom ((phi.a)*(phi.b)) = I
    by PARTFUN1:def 2;
    for j being Element of I holds (phi.(a * b)).j = ((phi.a) * (phi.b)).j
    proof
      let j be Element of I;
      reconsider fj = f.j as Homomorphism of G, F.j;
      (phi.(a * b)).j = fj.(a * b) by A3
                     .= (fj.a) * (fj.b) by GROUP_6:def 6
                     .= ((phi.a)/.j) * (fj.b) by A3
                     .= ((phi.a)/.j) * ((phi.b)/.j) by A3
                     .= ((phi.a) * (phi.b))/.j by GROUP_7:1;
      hence (phi.(a * b)).j = ((phi.a) * (phi.b)).j;
    end;
    hence phi.(a * b) = (phi.a) * (phi.b) by B1;
  end;
  then reconsider phi as Homomorphism of G, product F by GROUP_6:def 6;
  take phi;
  let g be Element of G;
  for j being Element of I holds (f.j).g = (proj (F, j)) . (phi.g)
  proof
    let j be Element of I;
    (f.j).g = (phi.g).j by A3;
    hence (f.j).g = (proj (F, j)).(phi.g) by Def16;
  end;
  hence thesis;
end;

:: Universal property of group product, as most people would recognize it.
theorem
  for f being Homomorphism-Family of G, F
  ex phi being Homomorphism of G, product F
  st (for i being Element of I holds f.i = (proj (F,i)) * phi)
proof
  let f be Homomorphism-Family of G, F;
  consider phi being Homomorphism of G, product F such that
  A1: for g being Element of G
      holds (for j being Element of I holds (f.j).g = (proj (F,j)) . (phi.g))
  by Th42;
  take phi;
  let i be Element of I;
  for g being Element of G holds ((proj (F,i)) * phi).g = (f.i).g
  proof
    let g be Element of G;
    (f.i).g = (proj (F,i)) . (phi.g) by A1
           .= ((proj (F,i)) * phi).g by FUNCT_2:15;
    hence (f.i).g = ((proj (F,i)) * phi).g;
  end;
  hence f.i = (proj (F,i)) * phi;
end;

theorem
  for f being Homomorphism-Family of G, F
  for phi1, phi2 being Homomorphism of G, product F
  st (for i being Element of I holds f.i = (proj (F,i)) * phi1)
     & (for i being Element of I holds f.i = (proj (F,i)) * phi2)
  holds phi1 = phi2
proof
  let f be Homomorphism-Family of G, F;
  let phi1, phi2 be Homomorphism of G, product F;
  assume A1: for i being Element of I holds f.i = (proj (F,i)) * phi1;
  assume A2: for i being Element of I holds f.i = (proj (F,i)) * phi2;
  for g being Element of G holds phi1.g = phi2.g
  proof
    let g be Element of G;
    phi1.g is Element of product (Carrier F) 
    & phi2.g is Element of product (Carrier F) by GROUP_7:def 2;
    then B1: dom (phi1.g) = I & dom (phi2.g) = I by PARTFUN1:def 2;
    for j being Element of I holds (phi1.g).j = (phi2.g).j
    proof
      let j be Element of I;
      C2: (f.j).g = ((proj (F, j)) * phi1).g by A1
                 .= (proj (F, j)) . (phi1.g) by FUNCT_2:15
                 .= (phi1.g).j by Def16;
      (f.j).g = ((proj (F, j)) * phi2).g by A2
             .= (proj (F, j)) . (phi2.g) by FUNCT_2:15
             .= (phi2.g).j by Def16;
      hence (phi1.g).j = (phi2.g).j by C2;
    end;
    hence phi1.g = phi2.g by B1;
  end;
  hence phi1 = phi2;
end;

definition
  let G be Group;
  let I be non empty set;
  let F be Group-Family of I;
  let f be Homomorphism-Family of G, F;
  func product f -> Homomorphism of G, product F means
  :Def17:
  for g being Element of G
  for i being Element of I
  holds (f.i).g = (it.g).i;
  existence
  proof
    consider phi being Homomorphism of G, product F such that
    A1: for g being Element of G
        holds (for j being Element of I holds (f.j).g = (proj (F,j)) . (phi.g))
    by Th42;
    take phi;
    for g being Element of G
    for j being Element of I holds (f.j).g = (phi.g).j
    proof
      let g be Element of G;
      let j be Element of I;
      (f.j).g = (proj (F,j)) . (phi.g) by A1
             .= (phi.g).j by Def16;
      hence thesis;
    end;
    hence thesis;
  end;
  uniqueness
  proof
    for phi1, phi2 being Homomorphism of G,product F
    st (for g being Element of G
        for i being Element of I
        holds (f.i).g = (phi1.g).i)
    & (for g being Element of G
       for i being Element of I
       holds (f.i).g = (phi2.g).i)
    holds phi1 = phi2
    proof
      let phi1,phi2 be Homomorphism of G,product F;
      assume A1: for g being Element of G
                 for i being Element of I
                 holds (f.i).g = (phi1.g).i;
      assume A2: for g being Element of G for i being Element of I
                 holds (f.i).g = (phi2.g).i;
      for g being Element of G
      holds phi1.g = phi2.g
      proof
        let g be Element of G;
        phi1.g is Element of product (Carrier F) 
        & phi2.g is Element of product (Carrier F) by GROUP_7:def 2;
        then A3: dom (phi1.g) = I & dom (phi2.g) = I by PARTFUN1:def 2;
        for j being Element of I holds (phi1.g).j = (phi2.g).j
        proof
          let j be Element of I;
          (phi1.g).j = (f.j).g by A1
                    .= (phi2.g).j by A2;
          hence (phi1.g).j = (phi2.g).j;
        end;
        hence phi1.g = phi2.g by A3;
      end;
      hence phi1 = phi2;
    end;
    hence thesis;
  end;
end;

theorem Th44:
  for g being Element of G
  holds (for i being Element of I holds ((product f).g).i = 1_(F.i))
  iff (product f).g = 1_(product F)
proof
  let g be Element of G;
  thus (for i being Element of I holds ((product f).g).i = 1_(F.i))
  implies (product f).g = 1_(product F)
  proof
    assume A1: for i being Element of I holds ((product f).g).i = 1_(F.i);
    set s = (product f).g;
    A2: for i being set
        st i in I
        holds (ex FG being non empty Group-like multMagma
               st FG = F.i & s.i = (1_FG))
    proof
      let i be set;
      assume i in I;
      then reconsider ii=i as Element of I;
      take FG = F.ii;
      thus thesis by A1;
    end;
    s is ManySortedSet of I
    proof
      s is Element of product (Carrier F) by GROUP_7:def 2;
      hence s is ManySortedSet of I;
    end;
    hence thesis by A2, GROUP_7:5;
  end;
  thus (product f).g = 1_(product F) implies
  (for i being Element of I holds ((product f).g).i = 1_(F.i)) by GROUP_7:6;
end;

theorem Th45:
  for g being Element of G
  holds g in Ker (product f)
        iff (for i being Element of I holds g in Ker (f.i))
proof
  let g be Element of G;
  thus g in Ker (product f)
       implies (for i being Element of I holds g in Ker (f.i))
  proof
    assume A1: g in Ker (product f);
    let i be Element of I;
    (product f).g = 1_(product F) by A1, GROUP_6:41;
    then 1_(F.i) = ((product f).g).i by Th44
                .= (f.i).g by Def17;
    hence g in Ker (f.i) by GROUP_6:41;
  end;
  thus (for i being Element of I holds g in Ker (f.i))
       implies g in Ker (product f)
  proof
    assume A1: for i being Element of I holds g in Ker (f.i);
    A2: for i being Element of I holds (f.i).g = 1_(F.i)
    proof
      let i be Element of I;
      g in Ker (f.i) by A1;
      hence (f.i).g = 1_(F.i) by GROUP_6:41;
    end;
    for i being Element of I holds ((product f).g).i = 1_(F.i)
    proof
      let i be Element of I;
      ((product f).g).i = (f.i).g by Def17
                       .= 1_(F.i) by A2;
      hence thesis;
    end;
    then (product f).g = 1_(product F) by Th44;
    hence g in Ker (product f) by GROUP_6:41;
  end;
end;

theorem Th46:
  for G1, G2, G3 being Group
  for f1 being Homomorphism of G1, G2
  for f2 being Homomorphism of G2, G3
  for g being Element of G1
  holds g in Ker (f2 * f1) iff f1.g in Ker(f2)
proof
  let G1, G2, G3 be Group;
  let f1 be Homomorphism of G1, G2;
  let f2 be Homomorphism of G2, G3;
  let g be Element of G1;
  thus g in Ker (f2 * f1) implies f1.g in Ker(f2)
  proof
    assume g in Ker (f2 * f1);
    then 1_(G3) = (f2 * f1).g by GROUP_6:41
               .= f2.(f1.g) by FUNCT_2:15;
    hence f1.g in Ker(f2) by GROUP_6:41;
  end;
  thus f1.g in Ker(f2) implies g in Ker (f2 * f1)
  proof
    assume f1.g in Ker(f2);
    then 1_G3 = f2.(f1.g) by GROUP_6:41
             .= (f2 * f1).g by FUNCT_2:15;
    hence g in Ker (f2 * f1) by GROUP_6:41;
  end;
end;

theorem
  for G1, G2, G3 being Group
  for f1 being Homomorphism of G1, G2
  for f2 being Homomorphism of G2, G3
  holds the carrier of Ker (f2 * f1) = f1" (the carrier of Ker f2)
proof
  let G1, G2, G3 be Group;
  let f1 be Homomorphism of G1, G2;
  let f2 be Homomorphism of G2, G3;
  A1: f1 "(the carrier of Ker f2) is Subset of G1
      & the carrier of Ker (f2 * f1) is Subset of G1
  by GROUP_2:def 5, FUNCT_2:39;
  for g being Element of G1
  st g in the carrier of Ker (f2 * f1)
  holds g in f1 " (the carrier of (Ker f2))
  proof
    let g be Element of G1;
    assume g in the carrier of Ker (f2 * f1);
    then g in Ker (f2 * f1);
    then f1.g in Ker f2 by Th46;
    hence g in f1 " (the carrier of (Ker f2)) by FUNCT_2:38;
  end;
  then
  A2: the carrier of Ker (f2 * f1) c= f1" (the carrier of Ker f2)
  by A1;
  for g being Element of G1
  st g in f1 " (the carrier of (Ker f2))
  holds g in the carrier of Ker (f2 * f1)
  proof
    let g be Element of G1;
    assume g in f1 " (the carrier of (Ker f2));
    then f1.g in Ker f2 by FUNCT_2:38;
    then g in Ker (f2 * f1) by Th46;
    hence g in the carrier of Ker (f2 * f1);
  end;
  then
  A3: f1" (the carrier of Ker f2) c= the carrier of Ker (f2 * f1) by A1;
  thus the carrier of Ker (f2 * f1) = f1" (the carrier of Ker f2)
  by A2,A3,XBOOLE_0:def 10;
end;

theorem
  the carrier of Ker (product f) = meet { the carrier of Ker (f.i) where
  i is Element of I : not contradiction }
proof
  set Fam = { the carrier of Ker (f.i) where i is Element of I
              : not contradiction };
  A1: Fam <> {}
  proof
    set i = the Element of I;
    the carrier of Ker (f.i) in Fam;
    hence thesis;
  end;
  A3: for g being object
  holds g in Ker (product f)
        iff (for A being set st A in Fam holds g in A)
  proof
    let g be object;
    hereby 
      assume B1: g in Ker (product f);
      let A be set;
      assume A in Fam;
      then consider i1 being Element of I such that
      B2: A = the carrier of Ker(f.i1);
      g in G & g in Ker (product f) by B1, GROUP_2:40;
      then g in Ker (f.i1) by Th45;
      hence g in A by B2;
    end;
    assume B1: for A being set st A in Fam holds g in A;
    g in G & for i being Element of I holds g in Ker (f.i)
    proof
      ex x being object st x in Fam by A1, XBOOLE_0:def 1;
      then consider A0 being set such that
      B2: A0 in Fam; 
      consider i0 being Element of I such that
      B3: A0 = the carrier of Ker (f.i0) by B2;
      g in Ker (f.i0) by B1, B2, B3;
      hence g in G by GROUP_2:40;
      
      let i be Element of I;
      the carrier of Ker (f.i) in Fam;
      hence g in Ker (f.i) by B1;
    end;

    hence g in Ker (product f) by Th45;
  end;
  A4: for g being object
  holds g in Ker (product f)
        iff g in (meet Fam)
  proof
    let g be object;
    g in Ker (product f) iff (for A being set st A in Fam holds g in A) by A3;
    hence thesis by A1, SETFAM_1:def 1;
  end;
  for g being object
  holds g in the carrier of Ker (product f) iff g in meet Fam
  proof
    let g be object;
    g in the carrier of Ker (product f) iff g in Ker (product f);
    hence thesis by A4;
  end;
  hence thesis by TARSKI:2;
end;

theorem Th49:
  for f being Function
  st dom f = I & (for i being Element of I holds f.i in F.i)
  holds f in product F
proof
  let f be Function;
  assume A1: dom f = I;
  assume A2: for i being Element of I holds f.i in F.i;
  A3: dom (Carrier F) = I by PARTFUN1:def 2;
  for i being object st i in dom (Carrier F) holds f.i in (Carrier F).i
  proof
    let i be object;
    assume B1: i in dom (Carrier F);
    then reconsider ii=i as Element of I;
    f.i in F.ii by A2;
    then B2: f.i in the carrier of (F.ii);
    ex R being 1-sorted st (R = F.i & (Carrier F).i = the carrier of R)
    by B1, PRALG_1:def 15;
    hence f.i in (Carrier F).i by B2;
  end;
  then f in product (Carrier F) by A1, A3, CARD_3:9;
  hence f in product F by GROUP_7:def 2;
end;

theorem
  for S being Group-Family of I
  for g being Element of product F
  holds g in product S iff (for i being Element of I
                            holds (proj (F,i)).g in S.i)
proof
  let S be Group-Family of I;
  let g be Element of product F;
  hereby 
    assume A1: g in product S;
    let i be Element of I;
    g.i in S.i by A1, GROUP_19:5;
    hence (proj (F,i)).g in S.i by Def16;
  end;
  assume Z2: for i being Element of I holds (proj (F,i)).g in S.i;
  Z3: dom g = I by GROUP_19:3;
  for i being Element of I holds g.i in S.i
  proof
    let i be Element of I;
    (proj (F, i)).g in S.i by Z2;
    hence g.i in S.i by Def16;
  end;
  hence g in product S by Z3, Th49;
end;

theorem
  for N being Group-Family of I
  st (for i being Element of I holds N.i is normal Subgroup of F.i)
  ex QG being Group-Family of I
  st (for i being Element of I
      ex Ni being normal Subgroup of F.i
      st Ni = N.i & QG.i = (F.i) ./. Ni)
proof
  let N be Group-Family of I;
  assume A1: for i being Element of I holds N.i is normal Subgroup of F.i;
  defpred PQ[Element of I, object] means ex Ni being normal Subgroup of
  F.$1 st Ni = N.$1 & $2 = (F.$1)./.Ni;
  B1: for i being Element of I ex j being object st PQ[i, j]
  proof
    let i be Element of I;
    reconsider Ni=N.i as normal Subgroup of F.i by A1;
    take j = (F.i)./.Ni;
    thus PQ[i, j];
  end;
  consider QG being ManySortedSet of I such that
  A3: for i being Element of I holds PQ[i, QG.i]
  from PBOOLE:sch 6(B1);
  for y being object st y in rng QG holds y is Group
  proof
    let y be object;
    assume y in rng QG;
    then consider x being object such that
    B1: x in dom QG & y = QG.x by FUNCT_1:def 3;
    reconsider i=x as Element of I by B1;
    PQ[i, y] by A3, B1;
    hence y is Group;
  end;
  then QG is Group-yielding by Def1;
  then reconsider QG as Group-Family of I;
  take QG;
  thus thesis by A3;
end;

theorem
  for QG being Group-Family of I
  st (for i being Element of I ex Ni being normal Subgroup of F.i
      st QG.i=(F.i)./.Ni)
  ex phi being Homomorphism-Family of (product F), QG
  st (for i being Element of I
      ex Ni being normal Subgroup of F.i
      st QG.i = (F.i)./.Ni & phi.i = (nat_hom Ni) * (proj (F, i)))
proof
  let QG be Group-Family of I;
  assume A1: for i being Element of I
             ex Ni being normal Subgroup of F.i
             st QG.i=(F.i)./.Ni;
  defpred P[Element of I, object] means ex Ni being normal Subgroup of
  F.$1 st QG.$1 = (F.$1)./.Ni & $2 = (nat_hom Ni) * (proj (F, $1));

  A2: for i being Element of I ex j being object st P[i, j]
  proof
    let i be Element of I;
    consider Ni being normal Subgroup of F.i such that
    B1: QG.i = (F.i)./.Ni by A1;
    take j = (nat_hom Ni) * (proj (F, i));
    thus P[i, j] by A1,B1;
  end;

  consider f being ManySortedSet of I such that
  A3: for i being Element of I holds P[i, f.i]
  from PBOOLE:sch 6(A2);
  
  A4: for i being Element of I holds f.i is Homomorphism of (product F), QG.i
  proof
    let i be Element of I;
    P[i, f.i] by A3;
    then consider Ni being normal Subgroup of F.i such that
    B1: QG.i = (F.i)./.Ni & f.i = (nat_hom Ni) * (proj (F, i));
    thus f.i is Homomorphism of (product F), QG.i by B1;
  end;
  then for i being object st i in dom f holds f.i is Function;
  then f is Function-yielding by FUNCOP_1:def 6;
  then reconsider f as Homomorphism-Family of (product F), QG by A4,Def13;
  take f;
  thus thesis by A3;
end;

theorem Th56:
  for F1,F2 being Group-Family of I
  st (for i being Element of I holds F1.i is Subgroup of F2.i)
  holds product F1 is Subgroup of product F2
proof
  let F1,F2 be Group-Family of I;
  assume A1: for i being Element of I holds F1.i is Subgroup of F2.i;
  deffunc Fun(Element of I) = (incl (F1.$1, F2.$1)) * (proj (F1, $1));
  A2: for i being Element of I
  holds Fun(i) is Homomorphism of product F1, F2.i
  proof
    let i be Element of I;
    B1: (proj (F1, i)) is Homomorphism of product F1, F1.i by Def16;
    incl (F1.i, F2.i) is Homomorphism of F1.i, F2.i;
    thus thesis by B1,GROUP_6:39;
  end;
  consider f being Homomorphism-Family of product F1, F2 such that
  A3: for i being Element of I holds f.i = Fun(i)
  from RHomFamSch(A2);
  A4: for g being Element of product F1
  for i being Element of I
  holds (f.i).g = g.i
  proof
    let g be Element of product F1;
    let i be Element of I;
    B1: F1.i is Subgroup of F2.i by A1;
    ((proj (F1, i)).g) in F1.i by Def16;
    then (g.i) is Element of F1.i by Def16;
    then B2: (incl (F1.i, F2.i)).(g.i) = g.i by B1, Th8;
    (f.i).g = ((incl (F1.i, F2.i)) * (proj (F1, i))).g by A3
           .= (incl (F1.i, F2.i)).((proj (F1, i)).g) by FUNCT_2:15
           .= (incl (F1.i, F2.i)).(g.i) by Def16
           .= (g.i) by B2;
    hence (f.i).g = g.i;
  end;
  consider phi being Homomorphism of product F1, product F2 such
  that
  A5: for g being Element of product F1
  holds (for i being Element of I holds (f.i).g = (proj (F2,i)) . (phi.g))
  by Th42;
  for g being Element of product F1
  holds phi.g = g
  proof
    let g be Element of product F1;
    B1: for i being object st i in I holds (phi.g).i = g.i
    proof
      let i be object;
      assume C1: i in I;
      then reconsider j=i as Element of I;
      g.j = (f.j).g by A4
         .= (proj (F2,j)) . (phi.g) by A5
         .= (phi.g).j by Def16;
      hence thesis;
    end;
    B2: dom g = I by GROUP_19:3;
    dom (phi.g) = I by GROUP_19:3;
    then dom g = dom (phi.g) by B2;
    hence g = phi.g by B1, B2, FUNCT_1:2;
  end;
  hence product F1 is Subgroup of product F2 by InclByAnyOtherName;
end;

definition
  let I be non empty set;
  let F be Group-Family of I;
  let S be Subgroup-Family of F;
  func product S -> strict Subgroup of product F equals product S;
  coherence
  proof
    for i being Element of I holds S.i is Subgroup of F.i;
    hence product S is strict Subgroup of product F by Th56;
  end;
end;

:: Kurosh, Theory of Groups, volume I, result VI about Direct Products
theorem
  for Z being Group-Family of I
  st (for i being Element of I holds Z.i = center (F.i))
  holds center (product F) = product Z
proof
  let Z be Group-Family of I;
  assume A1: for i being Element of I holds Z.i = center (F.i);
  A2: for a being Element of product F
  holds a in product Z iff (for b being Element of product F holds a*b = b*a)
  proof
    let a be Element of product F;
    thus a in product Z implies (for b being Element of product F
                                 holds a*b = b*a)
    proof
      assume B1: a in product Z;
      let b be Element of product F;
      reconsider ab=a*b, ba=b * a as Element of product F;
      ab in product F & ba in product F;
      then ab in product (Carrier F) & ba in product (Carrier F)
      by GROUP_7:def 2;
      then B3: dom ab = I & dom ba = I by PARTFUN1:def 2;
      for i being Element of I holds (a * b).i = (b * a).i
      proof
        let i be Element of I;
        a.i in Z.i by B1, GROUP_19:5;
        then C1: a.i in center (F.i) by A1;
        (a * b).i = (a/.i) * (b/.i) by GROUP_7:1
                 .= (b/.i) * (a/.i) by C1, GROUP_5:77
                 .= (b * a).i by GROUP_7:1;
        hence thesis;
      end;
      hence a*b = b*a by B3;
    end;
    thus (for b being Element of product F holds a*b = b*a)
         implies a in product Z
    proof
      assume B1: for b being Element of product F holds a*b = b*a;
      B2: for i being Element of I holds a.i in Z.i
      proof
        let i be Element of I;
        C1: for b being Element of product F
        holds (a/.i)*(b/.i) = (b/.i) * (a /.i)
        proof
          let b be Element of product F;
          (a * b).i = (a /. i) * (b /. i)
          & (b * a).i = (b /. i) * (a /. i) by GROUP_7:1;
          hence thesis by B1;
        end;
        for bi being Element of F.i holds (a/.i)*bi = bi*(a/.i)
        proof
          let bi be Element of F.i;
          reconsider b = (1ProdHom (F, i)).bi as Element of product F
          by GROUP_2:42;
          D1: dom (1_(product F)) = I by GROUP_19:3;
          b = (1_(product F)) +* (i, bi) by GROUP_12:def 3;
          then b/.i = bi by D1, FUNCT_7:31;
          hence thesis by C1;
        end;
        then a.i in center (F.i) by GROUP_5:77;
        hence a.i in Z.i by A1;
      end;
      a in product F;
      then a in product (Carrier F) by GROUP_7:def 2;
      then dom a = I by PARTFUN1:def 2;
      hence a in product Z by B2, Th49;
    end;
  end;

  A3: for a being Element of product F
  holds a in product Z iff a in center (product F)
  proof
    let a be Element of product F;
    hereby 
      assume a in product Z;
      then for b being Element of product F holds a*b = b*a by A2;
      hence a in center (product F) by GROUP_5:77;
    end;
    assume a in center (product F);
    then for b being Element of product F holds a*b = b*a by GROUP_5:77;
    hence a in product Z by A2;
  end;
  for i being Element of I holds Z.i is Subgroup of F.i
  proof
    let i be Element of I;
    Z.i = center (F.i) by A1;
    hence Z.i is Subgroup of F.i;
  end;
  then product Z is Subgroup of product F by GROUP_21:23;
  hence thesis by A3, GROUP_2:60;
end;

theorem
  for g being Element of product F
  holds g in Ker ((nat_hom ((F.i)`)) * (proj (F, i)))
        iff (proj (F,i)).g in (F.i)`
proof
  let g be Element of product F;
  set H=(F.i)./.((F.i)`);
  hereby
    assume A1: g in Ker ((nat_hom ((F.i)`)) * (proj (F, i)));
    (nat_hom ((F.i)`)).((proj (F,i)).g)
     = ((nat_hom ((F.i)`)) * (proj (F, i))).g by FUNCT_2:15
    .= 1_H by A1, GROUP_6:41;
    then (proj (F,i)).g in Ker (nat_hom ((F.i)`)) by GROUP_6:41;
    hence (proj (F,i)).g in (F.i)` by GROUP_6:43;
  end;
  assume (proj (F,i)).g in (F.i)`;
  then (proj (F,i)).g in Ker (nat_hom ((F.i)`)) by GROUP_6:43;
  then 1_H = (nat_hom ((F.i)`)).((proj (F,i)).g) by GROUP_6:41
          .= ((nat_hom ((F.i)`)) * (proj (F, i))).g by FUNCT_2:15;
  hence g in Ker ((nat_hom ((F.i)`)) * (proj (F, i))) by GROUP_6:41;
end;

theorem Th59:
  Image (proj (F, i)) = the multMagma of F.i
proof
  for x being Element of F.i st x in the carrier of F.i
  holds x in the carrier of Image (proj (F, i))
  proof
    let x be Element of F.i;
    assume A1: x in the carrier of F.i;
    ex g being Element of product F st x = (proj (F, i)).g
    proof
      dom (1_(product F)) = I by GROUP_19:3;
      then B1: ((1_(product F)) +* (i,x)).i = x by FUNCT_7:31;
      (1_(product F)) +* (i,x) in ProjSet (F, i) by A1, GROUP_12:def 1;
      then reconsider g = ((1_(product F)) +* (i,x)) as Element of product F;
      take g;
      (proj (F, i)).((1_(product F)) +* (i,x))
       = (proj (F, i)).g
      .= ((1_(product F)) +* (i,x)).i by Def16
      .= x by B1;
      hence thesis;
    end;
    then x in Image (proj (F, i)) by GROUP_6:45;
    hence x in the carrier of Image (proj (F, i)) by GROUP_6:def 10;
  end;
  then the carrier of F.i c= the carrier of Image (proj (F, i)) by SUBSET_1:2;
  hence thesis by GROUP_2:61;
end;

theorem Th60:
  for F1,F2 being componentwise_strict Subgroup-Family of F
  st (for i being Element of I
      holds Image (proj (F1, i)) is Subgroup of Image (proj (F2, i)))
  holds (product F1) is strict Subgroup of (product F2)
proof
  let F1,F2 be componentwise_strict Subgroup-Family of F;
  assume A1: for i being Element of I
  holds Image (proj (F1, i)) is Subgroup of Image (proj (F2, i));
  for i being Element of I holds F1.i is Subgroup of F2.i
  proof
    let i be Element of I;
    Image (proj (F1, i)) is Subgroup of Image (proj (F2, i)) by A1;
    then F1.i is Subgroup of Image (proj (F2, i)) by Th59;
    hence F1.i is Subgroup of F2.i by Th59;
  end;
  hence thesis by Th56;
end;

theorem Th64c:
  for G being strict Subgroup of product F
  for S st (for i being Element of I holds S.i = Image ((proj (F,i)) * (incl G)))
  for f being Homomorphism-Family of G, S
  st (for i being Element of I holds f.i = ((proj (F,i)) * (incl G)))
  holds product f = id the carrier of G
proof
  let G be strict Subgroup of product F;
  let S;
  assume A1: for i being Element of I
  holds S.i = Image ((proj (F,i)) * (incl G));
  let f be Homomorphism-Family of G, S;
  assume A2: for i being Element of I holds f.i = ((proj (F,i)) * (incl G));
  A3: for g being Element of G
  for i being Element of I
  holds ((proj (F,i)) * (incl G)).g = ((proj (F, i)) * (product f)).g
  proof
    let g be Element of G;
    let i be Element of I;
    for j being Element of I holds S.j is Subgroup of F.j; 
    then B1: (product S) is Subgroup of (product F) by Th56;
    ((product f).g) in (product S);
    then B2: ((product f).g) in (product F) by B1, GROUP_2:40;
    B3: ((product f).g).i = (proj (F, i)).((product f).g) by B2, Def16
                         .= ((proj (F, i)) * (product f)).g by FUNCT_2:15;
    ((proj (F,i)) * (incl G)).g = (f.i).g by A2
                               .= ((product f).g).i by Def17;
    hence ((proj (F,i)) * (incl G)).g = ((proj (F, i)) * (product f)).g by B3;
  end;
  A4: for g being Element of product F st g in G
  holds (product f).g = g
  proof
    let g be Element of product F;
    assume B1: g in G;
    ((product f).g) in (product F)
    proof
      for j being Element of I holds S.j is Subgroup of F.j;
      then C1: (product S) is Subgroup of (product F) by Th56;
      ((product f).g) in (product S) by B1, FUNCT_2:def 1, FUNCT_2:5;
      hence ((product f).g) in (product F) by C1, GROUP_2:40;
    end;
    then reconsider foo=(product f).g as Element of product F;
    B2: for i being Element of I
    holds ((proj (F, i)) * (incl G)).g = g.i
    proof
      let i be Element of I;
      ((proj (F,i)) * (incl G)).g
       = (proj (F, i)). ((incl G).g) by B1, FUNCT_2:15
      .= (proj (F, i)).((id the carrier of G).g) by DefIncl
      .= (proj (F, i)).g by B1, FUNCT_1:18
      .= g.i by Def16;
      hence thesis;
    end;
    B3: dom g = I & dom foo = I by GROUP_19:3;
    for i being Element of I holds foo.i = g.i
    proof
      let i be Element of I;
      (proj (F, i)).foo = ((proj (F,i)) * (product f)).g by B1, FUNCT_2:15
                       .= ((proj (F, i)) * (incl G)).g by B1, A3
                       .= g.i by B2;
      hence thesis by Def16;
    end;
    then foo = g by B3;
    hence (product f).g = g;
  end;
  for x being object st x in the carrier of G holds (product f).x = x
  proof
    let x be object;
    assume x in the carrier of G;
    then B1: x in G;
    then x in product F by GROUP_2:40;
    hence (product f).x = x by B1, A4;
  end;
  hence product f = id the carrier of G;
end;


theorem ThMappingFrobProdProperty:
  for G1, G2 being Group
  for phi being Homomorphism of G1, G2
  for F1 being FinSequence of the carrier of G1
  for F2 being FinSequence of the carrier of G2
  st len F1 = len F2 & F2 = phi * F1
  holds Product F2 = phi.(Product F1)
proof
  let G1, G2 be Group;
  let phi be Homomorphism of G1, G2;
  let F1 be FinSequence of the carrier of G1;
  let F2 be FinSequence of the carrier of G2;
  assume A1: len F1 = len F2;
  assume A2: F2 = phi * F1;
  A3: F2 = phi * F1 by A2;
  set n1 = len F1;
  defpred P1[FinSequence of the carrier of G1] means
  phi.(Product $1) = Product (phi * $1);
  B1: P1[ <*>(the carrier of G1) ]
  proof
    phi.(Product <*>(the carrier of G1))
     = phi.(1_G1) by GROUP_4:8
    .= 1_(G2) by GROUP_6:31
    .= Product (<*>(the carrier of G2)) by GROUP_4:8;
    hence thesis;
  end;
  B2: for p0 being FinSequence of the carrier of G1
  for x being Element of the carrier of G1 st P1[p0]
  holds P1[(p0 ^ <* x *>)]
  proof
    let p0 be FinSequence of the carrier of G1;
    let x be Element of the carrier of G1;
    assume C1: P1[p0];
    Product (p0 ^ <* x *>) = (Product p0) * x by GROUP_4:6;
    then phi.(Product (p0 ^ <* x *>))
     = (phi.(Product p0)) * (phi.x) by GROUP_6:def 6
    .= (Product (phi * p0)) * (phi.x) by C1
    .= Product ((phi * p0) ^ <* phi.x *>) by GROUP_4:6;
    hence P1[(p0 ^ <* x *>)] by FINSEQOP:8;
  end;
  A6: for p0 being FinSequence of the carrier of G1 holds P1[p0]
  from FINSEQ_2:sch 2(B1, B2);
  F2 = phi * F1
  proof
    B1: len F2 = len (phi * F1) by A1, FINSEQ_2:33;
    B2: for k being Nat st 1 <= k & k <= len F2 holds F2.k = (phi * F1).k
    proof
      let k be Nat;
      assume B3: 1 <= k & k <= len F2;
      then k in Seg n1 by A1, FINSEQ_1:1;
      then B4: k in dom F1 by FINSEQ_1:def 3;
      hence F2.k = (phi * F1).k by A1, A2, B3, FINSEQ_1:1;
    end;
    hence thesis by B1, FINSEQ_1:def 17;
  end;
  hence Product F2 = phi.(Product F1) by A6;
end;


theorem ThMappingFrobProd:
  for G1, G2 being Group
  for phi being Homomorphism of G1, G2
  for F1 being FinSequence of the carrier of G1
  ex F2 being FinSequence of the carrier of G2
  st len F1 = len F2
   & F2 = phi * F1
   & Product F2 = phi.(Product F1)
proof
  let G1, G2 be Group;
  let phi be Homomorphism of G1, G2;
  let F1 be FinSequence of the carrier of G1;
  set n1 = len F1;
  defpred P[object, object] means ex k being Nat st k = $1 &
  $2 = phi.(F1.k);
  A1: for k being Nat st k in Seg n1 holds ex x being object st P[k, x]
  proof
    let k be Nat;
    assume B1: k in Seg n1;
    then B2: k in dom F1 by FINSEQ_1:def 3;
    consider x being object such that
    B3: x = phi.(F1.k);
    take x;
    thus P[k, x] by B3;
  end;

  consider p being FinSequence such that
  A2: dom p = Seg n1 and
  A3: for k being Nat st k in Seg n1 holds P[k, p.k]
  from FINSEQ_1:sch 1(A1);
  A4: len F1 = len p by A2, FINSEQ_1:def 3;
  A5: p = phi * F1
  proof
    B1: len p = len (phi * F1) by A4, FINSEQ_2:33;
    B2: for k being Nat st 1 <= k & k <= len p holds p.k = (phi * F1).k
    proof
      let k be Nat;
      assume B3: 1 <= k;
      assume B4: k <= len p;
      then B5: k in Seg n1 by A4,B3,FINSEQ_1:1;
      then B6: k in dom F1 by FINSEQ_1:def 3;
      P[k, p.k] by A3, B5;
      then ex k0 being Nat st k0 = k & p.k = phi.(F1.k0);
      then B7: p.k = phi.(F1.k);
      (phi * F1).k = phi.(F1.k) by B6, FUNCT_1:13
                  .= p.k by B7;
      hence p.k = (phi * F1).k;
    end;
    hence thesis by B1, FINSEQ_1:def 17;
  end;
  then rng p c= the carrier of G2 by FINSEQ_1:def 4;
  then reconsider p as FinSequence of the carrier of G2 by FINSEQ_1:def 4;
  take F2 = p;

  thus len F1 = len F2 by A4;
  thus F2 = phi * F1 by A5;
  thus thesis by A4,A5,ThMappingFrobProdProperty;
end;

theorem ThMappingFrobProd2:
  for G1, G2 being Group
  for phi being Homomorphism of G1, G2
  for F1 being FinSequence of the carrier of G1
  for ks being FinSequence of INT st len F1 = len ks
  ex F2 being FinSequence of the carrier of G2
  st len F1 = len F2
   & F2 = phi * F1
   & Product (F2 |^ ks) = phi.(Product (F1 |^ ks))
proof
  let G1, G2 be Group;
  let phi be Homomorphism of G1, G2;
  let F1 be FinSequence of the carrier of G1;
  let ks be FinSequence of INT;
  assume A1: len F1 = len ks;
  consider F2 being FinSequence of the carrier of G2 such that
  A2: len F1 = len F2 & F2 = phi * F1 & Product F2 = phi.(Product F1)
  by ThMappingFrobProd;
  take F2;
  thus len F1 = len F2 & F2 = phi * F1 by A2;
  A3: len (F1 |^ ks) = len (F1) by GROUP_4:def 3
                    .= len F2 by A2
                    .= len (F2 |^ ks) by GROUP_4:def 3;
  then A4: len (phi * (F1 |^ ks)) = len (F1 |^ ks) by A3, FINSEQ_2:33;
  for k being Nat st k in dom (F2 |^ ks)
  holds (phi * (F1 |^ ks)).k = (F2 |^ ks).k
  proof
    let k be Nat;
    assume B1: k in dom (F2 |^ ks);
    then k in Seg (len (F2 |^ ks)) by FINSEQ_1:def 3;
    then k in Seg (len (F1 |^ ks)) by A3;
    then B2: k in dom (F1 |^ ks) by FINSEQ_1:def 3;
    then k in Seg (len (F1 |^ ks)) by FINSEQ_1:def 3;
    then k in Seg (len (F1)) by GROUP_4:def 3;
    then B3: k in dom F1 by A3, FINSEQ_1:def 3;
    then k in Seg (len (F1)) by FINSEQ_1:def 3;
    then k in Seg (len (F2)) by A2;
    then B3b: k in dom F2 by A3, FINSEQ_1:def 3;
    F1 /. k in G1 & dom phi = the carrier of G1 by FUNCT_2:def 1;
    then B4: F1 /. k in dom phi;
    set g = (F1 /. k);
    set n = (@ (ks /. k));
    phi.(g |^ n) = (phi.g) |^ n by GROUP_6:37;
    (F1 |^ ks).k = (F1 /. k) |^ (@ (ks /. k)) by B3, GROUP_4:def 3;
    (phi * (F1 |^ ks)).k = phi.((F1 |^ ks).k) by B2, FUNCT_1:13
    .= phi.((F1 /. k) |^ (@ (ks /. k))) by B3, GROUP_4:def 3
    .= (phi /. (F1 /. k)) |^ (@ (ks /. k)) by GROUP_6:37
    .= ((phi * F1)/.k) |^ (@ (ks /. k)) by B3, B4, PARTFUN2:4, FUNCT_1:13
    .= (F2 /. k) |^ (@ (ks /. k)) by A2
    .= (F2 |^ ks).k by B3b, GROUP_4:def 3;
    hence (phi * (F1 |^ ks)).k = (F2 |^ ks).k;
  end;

  then phi * (F1 |^ ks) = F2 |^ ks by A3, A4, FINSEQ_2:9;
  hence thesis by A3, ThMappingFrobProdProperty;
end;


theorem ThMorphismOfCommutators:
  for G1,G2 being Group
  for phi being Homomorphism of G1, G2
  for x being Element of G1 st x in commutators G1
  holds phi.x in commutators G2
proof
  let G1,G2 be Group;
  let phi be Homomorphism of G1, G2;
  let x be Element of G1;
  assume A1: x in commutators G1;
  then consider a,b being Element of G1 such that
  A2: x = [. a, b .] by GROUP_5:58;
  phi.x = phi.([. a, b .]) by A2
  .= [. (phi.a), (phi.b) .] by GROUP_6:34;
  hence phi.x in commutators G2 by GROUP_5:58;
end;

theorem
  for i being Element of I
  holds proj (F, i) .: the carrier of (product F)` = the carrier of (F.i)`
proof
  let i be Element of I;
  for y being object st y in the carrier of (F.i)`
  holds y in proj (F, i) .: the carrier of (product F)`
  proof
    let y be object;
    assume B1: y in the carrier of (F.i)`;
    ex x being object
    st (x in dom (proj (F,i)) & x in the carrier of (product F)`
        & y = (proj (F, i)).x)
    proof
      y in (F.i)` by B1;
      then y in F.i by GROUP_2:40;
      then reconsider yy=y as Element of F.i;
      (1ProdHom (F, i)).yy in ProjGroup (F, i);
      then (1ProdHom (F, i)).yy in product F by GROUP_2:40;
      then reconsider x=(1ProdHom (F, i)).yy as Element of product F;
      take x;
      dom (proj (F, i)) = the carrier of product F by FUNCT_2:def 1;
      hence x in dom (proj (F, i));
      yy in (F.i)` by B1;
      then consider gs being FinSequence of the carrier of (F.i),
      ks being FinSequence of INT such that
      C1: len gs = len ks and
      C2: rng gs c= commutators (F.i) and
      C3: yy = Product (gs |^ ks) by GROUP_5:73;

      consider hs being FinSequence of the carrier of ProjGroup (F,i)
      such that
      C4: len hs = len gs and
      C5: hs = (1ProdHom (F, i)) * gs and
      C6: Product (hs |^ ks) = (1ProdHom (F,i)).(Product (gs |^ ks))
      by C1, ThMappingFrobProd2;
      ex FS being FinSequence of the carrier of (product F) st
      ex I being FinSequence of INT
      st len FS = len I & rng FS c= commutators (product F)
         & x = Product (FS |^ I)
      proof
        the carrier of ProjGroup (F, i) c= the carrier of product F
        by GROUP_2:def 5;
        then hs is FinSequence of the carrier of product F
        by FINSEQ_2:24;
        then reconsider FS = hs as FinSequence of the carrier of product F;
        take FS;
        take I = ks;
        len ks = len gs by C1
              .= len FS by C4;
        hence D1: len FS = len I;

        for fs being object st fs in rng FS
        holds fs in commutators (product F)
        proof
          let fs be object;
          assume E1: fs in rng FS;
          then consider xs being object such that
          E2: xs in dom FS & fs = FS.xs by FUNCT_1:def 3;
          E3: xs in dom ((1ProdHom (F, i)) * gs) by C5, E2;
          E4: (1ProdHom (F, i)) is Homomorphism of F.i, product F by Th25;
          xs in dom gs by E3, FUNCT_1:11;
          then E5: gs.xs in commutators (F.i) by C2, FUNCT_1:3;
          fs = ((1ProdHom (F, i)) * gs).xs by C5,E2
            .= (1ProdHom (F, i)).(gs.xs) by E3, FUNCT_1:12;
          hence fs in commutators (product F)
          by E4, E5, ThMorphismOfCommutators;
        end;

        hence rng FS c= commutators (product F) by TARSKI:def 3;
        FS = hs;
        then D2: Product (FS |^ ks) = Product (hs |^ ks)
        by C1,D1,FrobProdSubgroup;
        x = (1ProdHom (F,i)).yy
         .= (1ProdHom (F,i)).(Product (gs |^ ks)) by C3
         .= Product (hs |^ ks) by C6;
        hence x = Product (FS |^ I) by D2;
      end;
      then x in (product F)` by GROUP_5:73;
      hence x in the carrier of (product F)`;
      (proj (F, i)).x = (proj (F, i)).((1ProdHom (F, i)).yy)
      .= ((proj (F, i)) * (1ProdHom (F, i))).yy by FUNCT_2:15
      .= (id the carrier of F.i).yy by Th65;
      hence y = (proj (F, i)).x;
    end;
    hence y in proj (F, i) .: the carrier of (product F)` by FUNCT_1:def 6;
  end;
  then A1: the carrier of (F.i)` c= proj (F, i) .: the carrier of (product F)`
  by TARSKI:def 3;

  
  for y being object st y in proj (F, i) .: the carrier of (product F)`
  holds y in the carrier of (F.i)`
  proof
    let y be object;
    assume B1: y in proj (F, i) .: the carrier of (product F)`;
    then consider x being object such that
    B2: x in dom (proj (F, i)) and
    B3: x in the carrier of (product F)` and
    B4: y = (proj (F, i)).x
    by FUNCT_1:def 6;
    x in (product F)` by B3;
    then consider xs being FinSequence of the carrier of (product F),
    ks being FinSequence of INT such that
    B5: len xs = len ks and
    B6: rng xs c= commutators (product F) and
    B7: x = Product (xs |^ ks)
    by GROUP_5:73;
    ex F2 being FinSequence of the carrier of F.i st
    ex I being FinSequence of INT st len F2 = len I
    & rng F2 c= commutators (F.i) & y = Product (F2 |^ I)
    proof
      consider F2 being FinSequence of the carrier of F.i such that
      C1: len xs = len F2 and
      C2: F2 = (proj (F, i)) * xs and
      C3: Product (F2 |^ ks) = (proj (F, i)).(Product (xs |^ ks))
      by B5, ThMappingFrobProd2;
      take F2;
      take I=ks;
      thus len F2 = len I by C1, B5;
      for fs being object st fs in rng F2 holds fs in commutators (F.i)
      proof
        let fs be object;
        assume D1: fs in rng F2;
        then consider n being object such that
        D2: n in dom F2 & fs = F2.n
        by FUNCT_1:def 3;
        D3: n in dom xs by C2,D2, FUNCT_1:11;
        D3b: xs.n in commutators (product F) by B6, D3, FUNCT_1:3, TARSKI:def 3;
        then consider a,b being Element of product F such that
        D4: xs.n = [. a, b .]
        by GROUP_5:58;
        D5: (proj (F, i)).a in F.i & (proj (F, i)).b in F.i;
        fs = ((proj (F, i)) * xs).n by C2,D2
          .= (proj (F, i)).(xs.n) by C2, D2, FUNCT_1:12
          .= (proj (F, i)).([. a, b .]) by D4
          .= [. (proj (F, i)).a, (proj (F, i)).b .] by GROUP_6:34;
        hence fs in commutators (F.i) by D5, GROUP_5:58;
      end;

      hence rng F2 c= commutators (F.i) by TARSKI:def 3;
      Product (F2 |^ ks) = (proj (F, i)).(Product (xs |^ ks)) by C3
                        .= (proj (F, i)).x by B7
                        .= y by B4;
      hence y = Product (F2 |^ I);
    end;
    then y in (F.i)` by GROUP_5:73;
    hence thesis;
  end;
  then
  A2: proj (F, i) .: the carrier of (product F)` c= the carrier of (F.i)`
  by TARSKI:def 3;
  thus proj (F, i) .: the carrier of (product F)` = the carrier of (F.i)`
  by A1,A2,XBOOLE_0:def 10;
end;


theorem
  for D being Group-Family of I
  st (for i being Element of I holds D.i = (F.i)`)
  holds (product F)` = product D
proof
  let D be Group-Family of I;
  assume A1: for i being Element of I holds D.i = (F.i)`;
  for i being Element of I holds D.i is Subgroup of F.i
  proof
    let i be Element of I;
    D.i = (F.i)` by A1;
    hence thesis; 
  end;
  then A2: product D is strict Subgroup of (product F) by GROUP_21:23;
  
  A3: (product F)` is strict Subgroup of (product D)
  proof
    for a, b being Element of (product F) holds [. a,b .] in product D
    proof
      let a, b be Element of (product F);
      set c = [. a, b .];
      B1: dom c = I by GROUP_19:3;
      for i being Element of I holds c.i in D.i
      proof
        let i be Element of I;
        C1: a/.i in (Omega).(F.i) & b/.i in (Omega).(F.i);
        c.i = ((((a") * (b")) * a) * b).i by GROUP_5:def 2
           .= (((((a") * (b")) * a))/.i) * (b/.i) by GROUP_7:1
           .= ((((a") * (b"))/.i * (a/.i))) * (b/.i) by GROUP_7:1
           .= ((((a")/.i * (b")/.i) * (a/.i))) * (b/.i) by GROUP_7:1
           .= (((((a/.i)") * ((b")/.i)) * (a/.i))) * (b/.i) by GROUP_7:8
           .= (((((a/.i)") * ((b/.i)")) * (a/.i))) * (b/.i) by GROUP_7:8
           .= [. (a/.i), (b/.i) .] by GROUP_5:def 2;
        then c.i in [. (Omega).(F.i), (Omega).(F.i) .] by C1, GROUP_5:65;
        then c.i in (F.i)` by GROUP_5:def 9;
        hence c.i in D.i by A1;
      end;
      hence c in product D by B1, Th49;
    end;
    hence thesis by A2, GROUP_6:7;
  end;

  A4: for g being Element of (product F) st g in (product D)
  holds g in Ker (nat_hom (product F)`)
  proof
    let g be Element of (product F);
    assume B1: g in (product D);
    set QG = (product F)./.((product F)`);
    
    deffunc PHI(Element of I) = (nat_hom ((F.$1)`)) * (proj (F, $1));
    deffunc PHI(Element of I) = nat_hom ((F.$1)`);
    consider phi being ManySortedSet of I such that
    B2: for i being Element of I holds phi.i = PHI(i)
    from PBOOLE:sch 5;
    for i being Element of I
    holds phi.i is Homomorphism of F.i, (F.i)./.((F.i)`)
    proof
      let i be Element of I;
      phi.i = PHI(i) by B2;
      hence phi.i is Homomorphism of F.i, (F.i)./.((F.i)`);
    end;
    then reconsider phi as Homomorphism-Family of (product F), D;
::>                                                            *4
      
    for i being Element of I
    for varphi being Homomorphism of (product F),D.i
    st varphi = (nat_hom ((F.i)`)) * (proj (F, i))
    ex fi being Homomorphism of QG,D.i
    st varphi = fi * (nat_hom ((product F)`))
     & Image fi = (1).(D.i);
::>                       *4

      :: construct the Homomorphism-Family from the varphi
      :: th

    ((nat_hom ((product F)`))/.g) = 1_(QG);
::>                                      *4
      :: then (nat_hom ((product F)`)).g = 1_(QG);
    hence g in Ker (nat_hom (product F)`) by GROUP_6:41;
  end;

  for g being Element of (product F) st g in (product D)
  holds g in (product F)`
  proof
    let g be Element of (product F);
    assume Z1: g in (product D);
    then g in Ker (nat_hom (product F)`) by A4;
    hence g in (product F)` by GROUP_6:43;
  end;
  then product D is strict Subgroup of (product F)` by A2, GROUP_2:58;
  hence thesis by A3, GROUP_2:55;
end;
::> 4: This inference is not accepted
