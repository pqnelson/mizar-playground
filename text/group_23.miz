:: Properties of Direct Product Groups
::  by Alex Nelson
::
:: This code can be distributed under the GNU General Public Licence
:: version 3.0 or later, or the Creative Commons Attribution-ShareAlike
:: License version 3.0 or later, subject to the binding interpretation
:: detailed in file COPYING.interpretation.
:: See COPYING.GPL and COPYING.CC-BY-SA for the full text of these
:: licenses, or see http://www.gnu.org/licenses/gpl.html and
:: http://creativecommons.org/licenses/by-sa/3.0/.

environ

 vocabularies RLVECT_2, ZFMISC_1, RELAT_1, STRUCT_0, FUNCOP_1,
   FUNCT_1, FUNCT_2, FUNCT_4, NUMBERS, CARD_3, BINOP_1,
   GROUP_1, GROUP_6, GROUP_7, GROUP_12, SUBSET_1, XBOOLE_0,
   GROUP_19, GROUP_23, PBOOLE;

 notations TARSKI, XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, RELSET_1,
   PARTFUN1, FUNCT_2, FUNCT_4, FUNCT_7, FUNCOP_1, PBOOLE, CARD_3,
   NUMBERS, XXREAL_0, FINSEQ_1, FINSEQ_2, STRUCT_0, ALGSTR_0, MONOID_0,
   GROUP_1, GROUP_2, GROUP_4, GROUP_6, PRALG_1, GROUP_7, GROUP_12,
   GROUP_17, GROUP_19;

 constructors PBOOLE, BINOP_1, REALSET1, FUNCT_4, FUNCOP_1, ALGSTR_0,
   MONOID_0, PRALG_1, GROUP_1, GROUP_2, GROUP_12, GROUP_4, GROUP_6,
   GROUP_7, FUNCT_7, RELSET_1, FUNCT_3, GROUP_17, GRSOLV_1, GROUP_19;

 registrations XBOOLE_0, XREAL_0, STRUCT_0, GROUP_2, MONOID_0, NAT_1,
   RELAT_1, FUNCT_1, PARTFUN1, RELSET_1, FUNCT_2, FUNCOP_1, CARD_3, ORDINAL1,
   FINSET_1, FINSEQ_1, NUMBERS, INT_1, INT_2, XCMPLX_0, CARD_1, NEWTON,
   FINSEQ_2, BINOP_1, GROUP_1, GROUP_3, GROUP_6, GR_CY_1, FUNCT_7,
   GROUP_7, GROUP_12, PBOOLE;

 definitions TARSKI, SUBSET_1, FUNCT_1, FUNCT_2, FUNCOP_1, FINSEQ_1,
   PRALG_1, GROUP_1, GROUP_3, GROUP_4, GROUP_6, XXREAL_0, GROUP_7,
   FUNCT_7;

 equalities PARTFUN1, FUNCT_7, FUNCOP_1, FINSET_1, BINOP_1, REALSET1,
   STRUCT_0, GROUP_2, GROUP_3, GROUP_4, GROUP_6, GR_CY_1, ALGSTR_0,
   PRALG_1, GROUP_7;

 expansions TARSKI, FUNCT_7, FINSET_1, GROUP_1, GROUP_2, GROUP_6,
   STRUCT_0, BINOP_1, FUNCT_2, PRALG_1, GROUP_7;

 theorems TARSKI, FUNCT_1, FUNCT_2, FUNCT_7, FUNCOP_1, GROUP_2,
   GROUP_6, GROUP_7, GROUP_12, GROUP_19, PARTFUN1;

 requirements BOOLE, SUBSET, NUMERALS, ARITHM, REAL;

 schemes FUNCT_2, PBOOLE;

begin

:: Uniqueness of morphisms to the trivial group
theorem Th1:
  for G being Group
  for H being trivial Group
  for f1,f2 being Homomorphism of G,H
  holds f1=f2
proof
  let G be Group;
  let H be trivial Group;
  let f1,f2 be Homomorphism of G,H;
  A1: the carrier of H = {1_H}
  proof
    H is trivial;
    then consider x being object such that
    B1: the carrier of H = {x};
    thus thesis by B1, TARSKI:def 1;
  end;
  for g being object st g in the carrier of G holds f1.g = f2.g
  proof
    let g be object;
    assume B1: g in the carrier of G;
    f1.g in H by B1,FUNCT_2:5;
    then B2: f1.g = 1_H by A1, TARSKI:def 1;
    f2.g in H by B1,FUNCT_2:5;
    then f2.g = 1_H by A1, TARSKI:def 1;
    hence f1.g = f2.g by B2;
  end;
  hence f1=f2;
end;

:: Universal property of terminal object for the trivial group
theorem Th2:
  for G being Group
  for H being trivial Group
  ex h being Homomorphism of G,H 
  st (for f being Homomorphism of G,H holds h=f)
proof
  let G be Group;
  let H be trivial Group;

  take h = 1:(G,H);
  thus thesis by Th1;
end;

theorem
  for G being Group
  for H being trivial Group
  for f being Homomorphism of G,H
  for g being Element of G
  holds f.g = 1_H
proof
  let G be Group;
  let H be trivial Group;
  let f be Homomorphism of G,H;
  let g be Element of G;
  1:(G,H) is Homomorphism of G,H;
  then f = 1:(G,H) by Th1;
  hence f.g = 1_H by Th1,FUNCOP_1:7;
end;

theorem Th4:
  for I being non empty set
  for F being Group-Family of I
  for i being Element of I
  for g being Element of product F
  holds g.i is Element of F.i
proof
  let I be non empty set;
  let F be Group-Family of I;
  let i be Element of I;
  let g be Element of product F;
  g is Function & g in product F;
  then g.i in F.i by GROUP_19:5;
  hence thesis;
end;

definition
  let I be non empty set;
  let F be Group-Family of I;
  let g be Element of product F;
  let i be Element of I;
  redefine func g.i -> Element of F.i;
  correctness by Th4;
end;

:: CARD_3:def
:: PRALG_3:def 2 
definition
  let I be non empty set;
  let i be Element of I;
  let F be Group-Family of I;
  func proj (F, i) -> Homomorphism of (product F), F.i means
  :Def1:
  for h being Element of product F holds it.h = h.i;
  existence
  proof
    deffunc F1() = product F;
    deffunc F2() = F.i;
    deffunc F3(Element of F1()) = $1.i;
    consider p being Function of F1(), F2() such that
    A1: for x being Element of F1() holds p.x = F3(x)
    from FUNCT_2:sch 4;
    reconsider p as Function of product F, F.i;
    
    for a, b being Element of product F
    holds p.(a * b) = (p.a) * (p.b)
    proof
      let a, b be Element of product F;
      (p.a) * (p.b) = (p.a) * (b.i) by A1
                   .= (a.i) * (b.i) by A1
                   .= (a * b).i by GROUP_7:1
                   .= p.(a * b) by A1;
      hence p.(a * b) = (p.a) * (p.b);
    end;
    then reconsider p as Homomorphism of product F,F.i by GROUP_6:def 6;
    take p;
    thus for h being Element of product F holds p.h = h.i by A1;
  end;
  uniqueness
  proof
    let p1,p2 be Homomorphism of (product F), F.i;
    assume A1: for h being Element of product F holds p1.h = h.i;
    assume A2: for h being Element of product F holds p2.h = h.i;
    for x being object st x in the carrier of product F holds p1.x = p2.x
    proof
      let x be object;
      assume x in the carrier of product F;
      then reconsider xx=x as Element of product F;
      p1.x = xx.i by A1
          .= p2.x by A2;
      hence p1.x = p2.x;
    end;
    hence p1 = p2;
  end;
end;

theorem Th6:
  for I being non empty set
  for i being Element of I
  for F being Group-Family of I
  holds proj (F, i) is onto
proof
  let I be non empty set;
  let i be Element of I;
  let F be Group-Family of I;
  for y being object
  holds y in the carrier of F.i iff
  ex x being object st x in dom (proj (F,i)) & y = (proj (F,i)).x
  proof
    let y be object;
    thus y in the carrier of F.i
         implies ex x being object
                 st x in dom (proj (F,i))
                    & y = (proj (F,i)).x
    proof 
      assume y in the carrier of F.i;
      then reconsider yy=y as Element of F.i;
      (1ProdHom (F, i)).yy in ProjGroup (F, i);
      then (1ProdHom (F, i)).yy in ProjSet (F, i) by GROUP_12:def 2;
      then consider x being Function, g being Element of F.i such that
      A1: x = (1ProdHom (F, i)).yy & dom x = I & x.i = g &
          for j being Element of I st j <> i holds x.j = 1_(F.j)
      by GROUP_12:2;

      the carrier of (product F) = product (Carrier F) by GROUP_7:def 2;
      then dom (1_(product F)) = I by PARTFUN1:def 2;
      then A2: y = ((1_(product F)) +* (i, y)).i by FUNCT_7:31
                .= x.i by A1, GROUP_12:def 3
                .= g by A1;
      A3: x in product F by A1,GROUP_2:41;
      take x;
      thus x in dom (proj (F,i)) by A3, FUNCT_2:def 1;
      thus y = (proj (F,i)).x by Def1, A1, A2, A3;
    end;
    thus (ex x being object st x in dom (proj (F,i)) & y = (proj (F,i)).x)
         implies y in the carrier of F.i
    proof
      given x being object such that 
      A1: x in dom (proj (F,i)) & y = (proj (F,i)).x;
      thus y in the carrier of F.i by A1, FUNCT_2:5;
    end;
  end;

  then rng (proj (F,i)) = the carrier of F.i by FUNCT_1:def 3;
  hence proj (F, i) is onto;
end;

definition
  let G be Group;
  let I be non empty set;
  let F be Group-Family of I;
  mode Homomorphism-Family of G,F -> ManySortedFunction of I means
  :Def2:
  for i being Element of I holds
  it.i is Homomorphism of G,F.i;
  existence
  proof
    deffunc F1() = I;
    deffunc F2(Element of I) = 1:(G,F.$1);
    consider f being ManySortedSet of F1() such that
    A1: for i being Element of F1() holds f.i = F2(i)
    from PBOOLE:sch 5;
    for x being object st x in dom f holds f.x is Function
    proof
      let x be object;
      assume B1: x in dom f;
      then x in I by A1,FUNCT_2:def 1;
      then reconsider i=x as Element of I;
      f.i = 1:(G,F.i) by A1;
      hence f.x is Function;
    end;
    then f is Function-yielding by FUNCOP_1:def 6;
    then reconsider f as ManySortedFunction of I;
    take f;
    thus A2: for i being Element of I holds f.i is Homomorphism of G,F.i
    proof
      let i be Element of I;
      f.i = 1:(G,F.i) by A1;
      hence f.i is Homomorphism of G,F.i;
    end;
  end;
end;

theorem
  for I being non empty set
  for F being Group-Family of I
  for G being Group
  for f being Homomorphism-Family of G, F
  ex phi being Homomorphism of G, product F
  st (for i being Element of I
      for g being Element of G
      holds f.i = (proj (F,i)) * phi)
proof
  let I be non empty set;
  let F be Group-Family of I;
  let G be Group;
  let f be Homomorphism-Family of G, F;
  consider phi being Homomorphism of G, product F;
  take phi;
  let i be Element of I;
  let g be Element of G;
  thus f.i = (proj (F,i)) * phi;
end;

::>                                 *4
    

::> 4: This inference is not accepted
