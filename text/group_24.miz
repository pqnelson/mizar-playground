:: Semidirect products of groups

environ

 vocabularies BINOP_1, XBOOLE_0, FUNCT_1, RELAT_1, ALGSTR_0, PRALG_1,
   FUNCOP_1, SUBSET_1, FUNCT_2, STRUCT_0, ZFMISC_1, CARD_3, MONOID_0, GROUP_1,
   GROUP_2, FINSEQ_1, GROUP_5, GROUP_6, PARTFUN1, MSSUBFAM, RLVECT_2, HAHNBAN,
   PRE_TOPC, WELLORD1, AUTGROUP, MOD_4, GROUP_24;
 notations TARSKI, XBOOLE_0, ENUMSET1, SUBSET_1, RELAT_1, FUNCT_1, ZFMISC_1,
   NAT_1, FINSEQ_1, RELSET_1, PARTFUN1, FUNCT_2, FUNCT_4, BINOP_1,
   PBOOLE, FUNCOP_1, STRUCT_0, ALGSTR_0, MONOID_0, GROUP_1, GROUP_2,
   GROUP_3, GROUP_5, GROUP_6, CARD_3, PRALG_1, AUTGROUP, GROUP_7, GROUP_22;
 constructors STRUCT_0, ALGSTR_0, ZFMISC_1, BINOP_1, XXREAL_0, REALSET1, GROUP_1,
   GROUP_3, GROUP_5, GROUP_6, MONOID_0, PRALG_1, PRALG_2, RELSET_1, FUNCT_4,
   AUTGROUP, GROUP_7, GROUP_22;
 registrations XBOOLE_0, SUBSET_1, RELAT_1, FUNCT_1, FINSET_1, XREAL_0,
   FINSEQ_1, REALSET1, STRUCT_0, GROUP_1, GROUP_2, GROUP_3, MONOID_0,
   ORDINAL1, CARD_3, FUNCOP_1, RELSET_1, FUNCT_2, FUNCT_4, GROUP_6,
   GROUP_7, GR_CY_2;
 requirements NUMERALS, BOOLE, SUBSET;
 definitions STRUCT_0, GROUP_1, TARSKI, GROUP_6, XBOOLE_0, PRALG_1, FUNCT_1,
   PBOOLE, ALGSTR_0, AUTGROUP;
 equalities FINSEQ_1, BINOP_1, REALSET1, STRUCT_0, ALGSTR_0, PARTFUN1, AUTGROUP;
 expansions STRUCT_0, GROUP_1, TARSKI, FINSEQ_1, FUNCT_1;
 theorems ALGSTR_0, PRALG_1, FUNCT_1, CARD_3, FUNCT_2, BINOP_1, TARSKI, ZFMISC_1,
   GROUP_1, GROUP_2, GROUP_3, GROUP_5, GROUP_6, FUNCT_4, FINSEQ_1, FINSEQ_3, ENUMSET1,
   RELSET_1, XBOOLE_0, XBOOLE_1, RELAT_1, FUNCOP_1, MONOID_0,
   PARTFUN1, AUTGROUP, GROUP_7, GROUP_22;
 schemes BINOP_1, FUNCT_1, PBOOLE, FUNCT_2, XBOOLE_0;

begin  :: The product of the families of the groups


registration
  let G be strict Group;
  cluster -> multiplicative for Element of Aut G;
  correctness by AUTGROUP:def 1;
end;

for G being strict Group
for f being Element of AutGroup G
holds f is Element of Aut G; :: by AUTGROUP:def 3;

LmDoubleCheckAutElementsAreMorphisms:
  for G being strict Group
  for f being Element of Aut G
  holds f is Homomorphism of G,G;


for G being strict Group
for A being Group
for phi being Homomorphism of A, AutGroup G
for a being Element of G
holds phi/.a is Element of AutGroup G;

Lm1:
for G being strict Group
for A being Group
for phi being Homomorphism of A, AutGroup G
for a being Element of A
holds phi/.a is Element of Aut G;

for G being strict Group
for A being Group
for phi being Homomorphism of A, AutGroup G
for a being Element of A
holds phi/.a is Homomorphism of G, G by Lm1;

reserve G for strict Group,
  A for Group,
  phi for Homomorphism of A, AutGroup G;

registration
  let G;
  cluster AutGroup G -> non empty strict constituted-Functions;
  coherence by MONOID_0:80;
end;

Lm1:
for G being strict Group
for A being Group
for phi being Homomorphism of A, AutGroup G
for a being Element of A
holds phi.a is Function;


definition
  let A,G,phi;
  :: let G be strict Group, A be Group;
  ::let phi be Homomorphism of A, AutGroup G;
  let a be Element of A;
  func phi /. a -> Function of G,G equals phi.a;
  correctness
  proof
    phi.a is Element of Aut G;
    then phi.a is Homomorphism of G,G;
    hence thesis;
  end;
end;


registration
  let G be strict Group, A be Group;
  let phi be Homomorphism of A, AutGroup G;
  let a be Element of A;
  cluster phi/.a -> multiplicative;
  coherence;
end;


LmCompose0:
  for phi being Homomorphism of A,AutGroup G
  for a1,a2 being Element of A
  for f1,f2,f12 being Homomorphism of G,G
  st f1 = phi.a1 & f2 = phi.a2 & f12 = phi.(a1 * a2)
  holds f1 * f2 = f12
proof
  let phi be Homomorphism of A,AutGroup G;
  let a1,a2 be Element of A;
  let f1,f2,f12 be Homomorphism of G,G;
  assume A1: f1 = phi.a1;
  assume A2: f2 = phi.a2;
  assume A3: f12 = phi.(a1 * a2);
  phi.(a1 * a2) = (phi.a1) * (phi.a2) by GROUP_6:def 6;
  hence thesis by A1,A2,A3, AUTGROUP:8;
end;

LmCompose1:
  for a1, a2 being Element of A
  for phi1, phi2 being Homomorphism of G,G
  st phi1 = phi.a1 & phi2 = phi.a2
  holds phi.(a1 * a2) = phi1 * phi2
proof
  let a1, a2 be Element of A;
  let phi1, phi2 be Homomorphism of G,G;
  assume A1: phi1 = phi.a1;
  assume A2: phi2 = phi.a2;
  reconsider a12 = a1 * a2 as Element of A;
  reconsider phi12 = (phi/.(a1 * a2)) as Homomorphism of G, G by Lm1;
  phi12 = phi.(a1 * a2); then
  phi12 = phi1 * phi2 by A1,A2,LmCompose0;
  hence thesis by A1,A2;
end;

LmCompose:
  for a1, a2 being Element of A
  holds phi.(a1 * a2) = (phi.a1) * (phi.a2)
proof
  let a1, a2 be Element of A;
  reconsider a12 = a1 * a2 as Element of A;
  reconsider phi12 = (phi/.(a1 * a2)) as Homomorphism of G, G by Lm1;
  reconsider phi1 = phi/.a1, phi2=phi/.a2 as Homomorphism of G,G by Lm1;
  A1: phi1 = phi.a1 & phi2 = phi.a2 & phi12 = (phi.(a1 * a2));
  then phi.(a1 * a2) = phi1 * phi2 by LmCompose1
                    .= (phi.a1) * (phi.a2) by A1, AUTGROUP:8;
  hence thesis by Lm1, AUTGROUP:8;
end;


:: :: Since there is no way to tell Mizar that the Element of AutGroup G
:: :: is automatically an Element of Aut G which is also automatically
:: :: a Function of G,G; we just short-circuit the whole machinery.
:: definition
::   let G be strict Group, A be Group;
::   let phi be Homomorphism of A, AutGroup G;
::   let a be Element of A;
::   func phi/.a -> Homomorphism of G,G equals phi.a;
::   coherence;
:: end;



registration
  let G, A;
  cluster product (Carrier <*A,G*>) -> non empty;
  correctness;
end;

Lm0:
  for x being Element of product (Carrier <*A,G*>)
  holds x.1 in A & x.2 in G
proof
  let x be Element of product (Carrier <*A,G*>);
  A1: dom (Carrier <*A,G*>) = {1,2} by PARTFUN1:def 2;

  A2: (Carrier <*A,G*>).1 = the carrier of A
  proof
    1 in {1,2} by TARSKI:def 2; then
    1 in dom (Carrier <*A,G*>) by A1; then
    ex R being 1-sorted st (R = <*A,G*>.1 & (Carrier <*A,G*>).1 = the
    carrier of R) by PRALG_1:def 15;
    hence thesis by FINSEQ_1:44;
  end;
  A3: (Carrier <*A,G*>).2 = the carrier of G
  proof
    2 in {1,2} by TARSKI:def 2; then
    2 in dom (Carrier <*A,G*>) by A1; then
    ex R being 1-sorted st (R = <*A,G*>.2 & (Carrier <*A,G*>).2 = the
    carrier of R) by PRALG_1:def 15;
    hence thesis by FINSEQ_1:44;
  end;
  x in product (Carrier <*A,G*>);
  then dom x = dom (Carrier <*A,G*>) & (for i being object st i in dom
  (Carrier <*A,G*>) holds x.i in (Carrier <*A,G*>).i) by CARD_3:9;
  then A4: dom x = {1,2} & (for i being object st i in {1,2} holds x.i in (Carrier <*A,G*>).i) by A1;

  1 in {1,2} by TARSKI:def 2;
  then x.1 in (Carrier <*A,G*>).1 by A4;
  then x.1 in the carrier of A by A2;
  hence x.1 in A;

  2 in {1,2} by TARSKI:def 2;
  then x.2 in (Carrier <*A,G*>).2 by A4;
  then x.2 in the carrier of G by A3;
  hence x.2 in G;
end;


Lm1:
  for a being Element of A, g being Element of G
  holds <*a,g*> in product (Carrier <*A,G*>)
proof
  let a be Element of A;
  let g be Element of G;
  <*a,g*> in (product <*A,G*>); then
  <*a,g*> in the carrier of (product <*A,G*>);
  hence <*a,g*> in product (Carrier <*A,G*>) by GROUP_7:def 2;
end;

:: Using notation from Aschbacher's "Finite Group Theory" Section 10,
:: but Aschbacher uses "backwards" notation for function
:: composition...so we fix it.
definition
  let A, G, phi;
  func semidirect_product (A, G, phi) -> non empty strict multMagma means
  :Def1:
  the carrier of it = product (Carrier <* A, G *>) &
  (for f, g being Element of product (Carrier <* A, G *>)
   ex h being Function, a1 being Element of A, g2 being Element of G
   st h = (the multF of it).(f, g) &
      a1 = f.1 & g2 = g.2 &
      h.1 = (the multF of A).((f.1), (g.1)) &
      h.2 = (the multF of G).(f.2, (phi/.a1)/. g2));
  :: the carrier of it = the carrier of product <* A, G *> &
  :: for a1,a2 being Element of A
  :: for g1,g2 being Element of G
  :: holds (the multF of it).(<*a1, g1*>, <*a2, g2*>)
  ::       = <*a1 * a2, ((phi/.a2)/.g1)*g2 *>;
  existence
  proof
    set U = product (Carrier <* A, G *>);
    defpred P[Element of U, Element of U, set] means
    ex h being Function, a1 being Element of A, g2 being Element of G
    st h = $3 & a1 = $1.1 & g2 = $2.2 &
       h.1 = (the multF of A).(($1.1), ($2.1)) &
       h.2 = (the multF of G).($1.2, (phi/.a1)/. g2);

    A1: for x, y being Element of U ex z being Element of U st P[x,y,z]
    proof
      let x, y be Element of U;
      
      ex z being Element of U st P[x, y, z]
      proof
        C1: dom (Carrier <*A,G*>) = {1,2} by PARTFUN1:def 2;
        x is Element of product (Carrier <*A,G*>); then
        x.1 in A by Lm0; then
        reconsider a1 = x.1 as Element of A;
        y is Element of product (Carrier <*A,G*>); then
        y.2 in G by Lm0; then
        reconsider g2 = y.2 as Element of G;

        set h = <* (the multF of A).(x.1, y.1), (the multF of G).(x.2,(phi/.a1)/.g2)*>;
        C2: h = <* (the multF of A).(x.1, y.1), (the multF of G).(x.2,(phi/.a1)/.g2)*>;
        C3: h = <* h.1, h.2 *>
        proof
          D1: len h = 2 by C2, FINSEQ_1:44;
          h.1 = h.1 & h.2 = h.2;
          hence thesis by D1, FINSEQ_1:44;
        end;
        h in product (Carrier <*A,G*>)
        proof
          x.1 in A & y.1 in A by Lm0; then
          (the multF of A).(x.1, y.1) in A by BINOP_1:17;
          then h.1 in A by C1,FINSEQ_1:44;
          then D1: h.1 is Element of A;
          (phi/.a1)/.g2 in G & x.2 in G by Lm0; then
          (the multF of G).(x.2, (phi/.a1)/.g2) in G by BINOP_1:17;
          then h.2 in G by C1,FINSEQ_1:44;
          then h.2 is Element of G;
          then <*h.1,h.2*> is Element of product (Carrier <*A,G*>) by D1,Lm1;
          then h is Element of product (Carrier <*A, G*>) by C3;
          hence thesis by D1,Lm1;
        end;
        then reconsider z = h as Element of product (Carrier <*A,G*>);
        take z;
        h = z & a1 = x.1 & g2 = y.2 &
        h.1 = (the multF of A).(x.1, y.1) &
        h.2 = (the multF of G).(x.2, (phi/.a1)/.g2) by C2, FINSEQ_1:44;
        hence P[x, y, z] by C2;
      end;
      hence thesis;
    end;

    consider B being Function of [:U, U:],U such that
A2: for a, b being Element of U holds P[a,b,B.(a,b)] from BINOP_1:sch 3(A1);

    set M = multMagma(# (product (Carrier <*A,G*>)), B #);
    reconsider M as non empty strict multMagma;
    take M;
    thus thesis by A2;
  end;
  uniqueness
  proof
    let M1,M2 being non empty strict multMagma;
    assume that
    A1: (the carrier of M1 = product (Carrier <* A, G *>) &
         (for f, g being Element of product (Carrier <* A, G *>)
          ex h being Function, a1 being Element of A, g2 being Element of G
          st h = (the multF of M1).(f, g) &
             a1 = f.1 & g2 = g.2 &
             h.1 = (the multF of A).((f.1), (g.1)) &
             h.2 =  (the multF of G).(f.2, (phi/.a1)/. g2))) and
    A2: (the carrier of M2 = product (Carrier <* A, G *>) &
         (for f, g being Element of product (Carrier <* A, G *>)
          ex h being Function, a1 being Element of A, g2 being Element of G
          st h = (the multF of M2).(f, g) &
             a1 = f.1 & g2 = g.2 &
             h.1 = (the multF of A).((f.1), (g.1)) &
             h.2 =  (the multF of G).(f.2, (phi/.a1)/. g2)));
    A3: the carrier of M1 = the carrier of M2 by A1,A2;

    for x,y being set st x in the carrier of M1 & y in the carrier of M1
    holds (the multF of M1).(x, y) = (the multF of M2).(x, y) 
    proof
      let x,y be set;
      assume B1: x in the carrier of M1;
      assume B2: y in the carrier of M1;
      reconsider f = x, g = y as Element of product (Carrier <*A,G*>) by A1,B1,B2;
      consider h1 being Function, a11 being Element of A, g12 being Element of G
      such that
      B3: h1 = (the multF of M1).(f, g) and
      B4: a11 = f.1 & g12 = g.2 and
      B5: h1.1 = (the multF of A).((f.1), (g.1)) and
      B6: h1.2 = (the multF of G).(f.2, (phi/.a11)/. g12) by A1;
      consider h2 being Function, a21 being Element of A, g22 being Element of G
      such that
      B7: h2 = (the multF of M2).(f, g) and
      B8: a21 = f.1 & g22 = g.2 and
      B9: h2.1 = (the multF of A).((f.1), (g.1)) and
      B10: h2.2 = (the multF of G).(f.2, (phi/.a21)/. g22) by A2;
      B11: dom h1 = {1,2} & dom h2 = {1,2}
      proof
        C1: dom (Carrier <*A,G*>) = {1,2} by PARTFUN1:def 2;
        (the multF of M1).(f, g) in product (Carrier <*A,G*>) by B3,A1, BINOP_1:17;
        then h1 in product (Carrier <*A,G*>) by B3;
        then ex f1 being Function st h1 = f1 & dom f1 = dom (Carrier <*A,G*>)
        & (for y1 being object st y1 in dom (Carrier <*A,G*>)
        holds f1.y1 in (Carrier <*A,G*>).y1)
        by C1, A1, CARD_3:def 5;
        hence dom h1 = {1,2} by C1;

        (the multF of M2).(f, g) in product (Carrier <*A,G*>) by B7,A2, BINOP_1:17;
        then h2 in product (Carrier <*A,G*>) by B7;
        then ex f1 being Function st h2 = f1 & dom f1 = dom (Carrier <*A,G*>)
        & (for y1 being object st y1 in dom (Carrier <*A,G*>)
        holds f1.y1 in (Carrier <*A,G*>).y1)
        by C1, A2, CARD_3:def 5;
        hence dom h2 = {1,2} by C1;
      end;
      for i being object st i in dom h1 holds h1.i = h2.i
      proof
        let i be object;
        assume i in dom h1;
        then i in {1,2} by B11;
        then per cases by TARSKI:def 2;
        suppose i = 1;
          hence thesis by B5,B9;
        end;
        suppose i = 2;
          hence thesis by B4,B6,B8,B10;
        end;
      end;
      then h1 = h2 by B11,FUNCT_1:2;
      hence (the multF of M1).(x, y) = (the multF of M2).(x, y) by B3,B7;
    end;

    then the multF of M1 = the multF of M2 by A1,A2,BINOP_1:1;
    hence thesis by A3;
    end;
end;


registration
  let A, G, phi;
  cluster semidirect_product (A, G, phi) -> non empty strict constituted-Functions;
  coherence
  proof
    the carrier of semidirect_product (A, G, phi) = product (Carrier <*A,G*>)
    by Def1;
    hence thesis by MONOID_0:80;
  end;
end;

registration
  let A, G, phi;
  cluster -> FinSequence-like for Element of (semidirect_product (A, G, phi));
  coherence
  proof
    for b1 being Element of semidirect_product(A, G, phi)
    holds b1 is FinSequence-like
    proof
      let b1 be Element of semidirect_product(A, G, phi);
      b1 is Element of product (Carrier <*A,G*>) by Def1;
      hence b1 is FinSequence-like;
    end;
    hence thesis;
  end;
end;

registration
  let A, G, phi;
  cluster -> FinSequence-like for Element of the carrier of (semidirect_product (A, G, phi));
  coherence;
end;

theorem th2:
  the carrier of semidirect_product (A, G, phi) = the carrier of product <*A,G*>
proof
  thus the carrier of semidirect_product (A,G,phi)
   = product (Carrier <*A,G*>) by Def1
  .= the carrier of product <*A,G*> by GROUP_7:def 2;
end;

theorem th3:
  for a being Element of A
  for g being Element of G
  holds <* a, g *> is Element of semidirect_product (A, G, phi) by th2,GROUP_7:def 2;

theorem th4:
  for x being Element of semidirect_product (A, G, phi)
  holds x.1 in A & x.2 in G & dom x = {1,2}
proof
  let x be Element of semidirect_product (A, G, phi);
  A1: dom (Carrier <*A,G*>) = {1,2} by PARTFUN1:def 2;
  x in semidirect_product (A, G, phi);
  then x in product (Carrier <*A,G*>) by Def1;
  then consider f being Function such that
  A2: x = f & dom f = dom (Carrier <*A,G*>) & (for y being object st y
  in dom (Carrier <*A,G*>) holds f.y in (Carrier <*A,G*>).y)
  by A1, Def1, CARD_3:def 5;

  A3: <* A, G *>.1 = A by FINSEQ_1:44;
  A4: <* A, G *>.2 = G by FINSEQ_1:44;

  thus x.1 in A
  proof
    1 in {1,2} by TARSKI:def 2;
    then B1: 1 in dom (Carrier <*A,G*>) by A1;
    then ex R being 1-sorted st
    (R = <*A,G*>.1 & (Carrier <*A,G*>).1 = the carrier of R) by PRALG_1:def 15;
    then (Carrier <*A,G*>).1 = the carrier of A by A3;
    then x.1 in the carrier of A by A2, B1;
    hence thesis;
  end;

  thus x.2 in G
  proof
    2 in {1,2} by TARSKI:def 2;
    then B1: 2 in dom (Carrier <*A,G*>) by A1;
    then ex R being 1-sorted st
    (R = <*A,G*>.2 & (Carrier <*A,G*>).2 = the carrier of R) by PRALG_1:def 15;
    then (Carrier <*A,G*>).2 = the carrier of G by A4;
    then x.2 in the carrier of G by A2, B1;
    hence thesis;
  end;
  thus dom x = {1,2} by A1,A2;
end;

theorem th5:
  for x being Element of semidirect_product (A, G, phi)
  ex a being Element of A, g being Element of G
  st x = <* a, g *>
proof
  let x be Element of semidirect_product (A, G, phi);

  x.1 in A & x.2 in G by th4;
  then consider a being Element of A, g being Element of G such that
  A1: a = x.1 & g = x.2;

  take a, g;
  
  dom x = {1,2} by th4;
  then len x = 2 by FINSEQ_1:2,def 3;
  hence x = <* a, g *> by A1, FINSEQ_1:44;
end;

Lm1:
  for x1, x2, y1, y2 being object
  holds <*x1,y1*> = <*x2,y2*> iff (x1 = x2 & y1 = y2)
proof
  let x1, x2, y1, y2 be object;
  thus <*x1,y1*> = <*x2,y2*> implies (x1 = x2 & y1 = y2)
  proof
    assume A1: <*x1,y1*> = <*x2,y2*>;
    thus x1 = <*x1,y1*>.1 by FINSEQ_1:44
           .= <*x2,y2*>.1 by A1
           .= x2 by FINSEQ_1:44;
    thus y1 = <*x1,y1*>.2 by FINSEQ_1:44
           .= <*x2,y2*>.2 by A1
           .= y2 by FINSEQ_1:44;
  end;
  thus (x1 = x2 & y1 = y2) implies <*x1,y1*> = <*x2,y2*> by FINSEQ_1:44;
end;

theorem th6:
  for x,y being Element of semidirect_product (A, G, phi)
  for a1,a2 being Element of A
  for g1,g2 being Element of G
  st x = <*a1,g1*> & y = <*a2,g2*>
  holds x * y = <* a1 * a2, g1 * ((phi /. a1)/.g2) *>
proof
  let x,y be Element of semidirect_product (A, G, phi);
  let a1,a2 be Element of A;
  let g1,g2 be Element of G;
  assume A1: x = <*a1,g1*>;
  assume A2: y = <*a2,g2*>;
  
  x in product (Carrier <* A, G*>) & y in product (Carrier <*A,G*>)
  proof
    x in semidirect_product(A,G,phi);
    hence x in product (Carrier <*A,G*>) by Def1;
    y in semidirect_product(A,G,phi);
    hence y in product (Carrier <*A,G*>) by Def1;
  end;

  then consider h being Function, aa1 being Element of A, gg2 being Element
  of G such that
  A3: h = x * y & aa1 = x.1 & gg2 = y.2 and
  A4: h.1 = (the multF of A).(x.1, y.1) and
  A5: h.2 = (the multF of G).(x.2, (phi/.aa1)/.gg2) by Def1;

  A6: a1 = aa1 & g2 = gg2 by A1,A2,A3,FINSEQ_1:44;

  h.1 = (the multF of A).(x.1, y.1) by A4
     .= (the multF of A).(x.1, a2) by A2,A3,A6,FINSEQ_1:44
     .= (the multF of A).(a1, a2) by A1,FINSEQ_1:44;
  then
  A7: (x * y).1 = a1 * a2 by th4,A1,A2,A3,A4,A5,Def1;
  h.2 = (the multF of G).(x.2, (phi/.aa1)/.gg2) by A5
     .= (the multF of G).(x.2, (phi/.a1)/.g2) by A6
     .= (the multF of G).(g1, (phi/.a1)/.g2) by A1,A2,FINSEQ_1:44;
  then A8: (x * y).2 = g1 * ((phi /. a1)/.g2) by th4,A1,A2,A3,A4,A5,Def1;

  dom (x * y) = {1,2} by th4;
  then len (x * y) = 2 by FINSEQ_1:2,def 3;
  hence x * y = <* a1 * a2, g1 * ((phi /. a1)/.g2) *> by A7,A8,FINSEQ_1:44;
end;

theorem th7:
  for g being Element of G
  holds (phi /. 1_A) /. g = g
proof
  let g be Element of G;
  (phi /. 1_A) = 1_(AutGroup G) by GROUP_6:31
              .= id the carrier of G by AUTGROUP:9;
  hence (phi /. 1_A) /. g = g;
end;


theorem th8:
  for x,e being Element of semidirect_product (A, G, phi)
  st e = <* 1_A, 1_G*>
  holds x * e = x & e * x = x
proof
  let x,e be Element of semidirect_product (A, G, phi);
  assume A1: e = <* 1_A, 1_G*>;
  consider a being Element of A, g being Element of G such that
  A2: x = <* a, g *>
  by th5;

  A3: ((phi /. (1_A)) /. g) * 1_G = g * 1_G by th7
                                 .= g by GROUP_1:def 4;
  A4: ((phi /. a) /. (1_G)) = 1_G by GROUP_6:31;
  thus x * e = <* a * 1_A, g * ((phi /. a) /. 1_G) *> by A1,A2, th6
            .= <* a, g * ((phi /. a) /. 1_G) *> by GROUP_1:def 4
            .= <* a, g * 1_G *> by A4
            .= <* a, g *> by GROUP_1:def 4
            .= x by A2;
  thus e * x = <* 1_A * a, 1_G * ((phi /. (1_A)) /. g) *> by A1,A2,th6
            .= <* a, 1_G * ((phi /. (1_A)) /. g) *> by GROUP_1:def 4
            .= <* a, (1_G) * (g) *> by A3, GROUP_1:def 4
            .= <* a, (1_G) * g *> by A3, GROUP_1:def 4
            .= <* a, g *> by GROUP_1:def 4
            .= x by A2;
end;


:: :: The problem is that phi does not appear in the Loci of this
:: :: definition, so Mizar is not happy :'(
:: definition
::   let A, G, phi;
::   let a be Element of A;
::   let g be Element of G;
::   redefine func <*a,g*> -> Element of (semidirect_product (A, G, phi));
:: ::>              *100
::   coherence;
:: end;

theorem th9:
  for a1,a2 being Element of A
  for g being Element of G
  holds (phi.a1) . ((phi /. a2) . g) = (phi /. (a1 * a2)) . g
proof
  let a1,a2 be Element of A;
  let g be Element of G;
  phi . (a1 * a2) = (phi.a1) * (phi.a2) by LmCompose,GROUP_6:def 6;
  then (phi . (a1 * a2)) . g = ((phi.a1) * (phi.a2)).g
                            .= ((phi/.a1) * (phi/.a2)).g by AUTGROUP:8
                            .= (phi.a1) . ((phi . a2) . g) by FUNCT_2:15;
  hence (phi.a1) . ((phi /. a2) . g) = (phi /. (a1 * a2)) . g by GROUP_6:def 6;
end;

theorem th10:
  for a being Element of A
  for g being Element of G
  holds (phi/.(a")) /. ((phi /. a) /. g) = g
  & (phi/. a) /. ((phi /. (a")) /. g) = g
proof
  let a be Element of A;
  let g be Element of G;
  thus (phi /. (a")) /. ((phi /. a) /. g) = (phi /. (a" * a)) /. g by th9
                                         .= (phi /. 1_A) /. g by GROUP_1:def 5
                                         .= g by th7;
  thus (phi/. a) /. ((phi /. (a")) /. g) = (phi /. (a * a")) /. g by th9
                                        .= (phi /. 1_A) /. g by GROUP_1:def 5
                                        .= g by th7;
end;

theorem th11:
  for x,y,e being Element of semidirect_product (A, G, phi)
  for a being Element of A
  for g being Element of G
  st x = <* a, g *> & e = <* 1_A, 1_G *> & y = <* a", (phi/.(a"))/.(g") *>
  holds x * y = e & y * x = e
proof
  let x,y,e be Element of semidirect_product (A, G, phi);
  let a be Element of A;
  let g be Element of G;
  assume A1: x = <* a, g *>;
  assume A2: e = <* 1_A, 1_G *>;
  assume A3: y = <* a", (phi/.(a"))/.(g") *>;
  A4: ((phi /. (a")) /. (g")) * ((phi/.(a"))/.(g))
   = (phi /. (a")) /. (g" * g) by GROUP_6:def 6
  .= (phi /. (a")) /. 1_G by GROUP_1:def 5
  .= 1_G by GROUP_6:31;
  A5: ((phi /. a) /. ((phi/.(a"))/.(g"))) = g" by th10;

  thus x * y = <* a * (a"), g * ((phi/.a)/.((phi/.(a"))/.(g"))) *> by A1,A3,th6
            .= <* a * (a"), g * g" *> by A5
            .= <* a * a", 1_G *> by GROUP_1:def 5
            .= <* 1_A, 1_G *> by GROUP_1:def 5
            .= e by A2;
  thus y * x = <* (a") * a, (phi/.(a")).(g") * ((phi/. a")/.g)*> by A1,A3,th6
            .= <* (a") * a, 1_G*> by A4
            .= <* 1_A, 1_G *> by GROUP_1:def 5
            .= e by A2;
end;

theorem th12:
  for G being strict Group
  for A being Group
  for phi being Homomorphism of A, AutGroup G
  ex e being Element of semidirect_product (A, G, phi)
  st (for h being Element of semidirect_product (A, G, phi)
      holds h * e = h & e * h = h
      & ex g being Element of semidirect_product (A, G, phi)
      st h * g = e & g * h = e)
proof
  let G be strict Group;
  let A be Group;
  let phi be Homomorphism of A, AutGroup G;
  <* 1_A, 1_G *> is Element of semidirect_product (A, G, phi) by th3;
  then consider e being Element of semidirect_product (A, G, phi) such that
  A1: e = <* 1_A, 1_G *>
  by th3;
  take e;
  A2: for h being Element of semidirect_product (A, G, phi)
  holds h * e = h & e * h = h by A1, th8;

  for h being Element of semidirect_product (A, G, phi)
  ex g being Element of semidirect_product (A, G, phi)
  st h * g = e & g * h = e
  proof
    let h be Element of semidirect_product (A, G, phi);
    consider a being Element of A, g being Element of G such that
    B1: h = <* a, g *> by th5;
    set g2 = (phi/.(a"))/.(g");
    reconsider g2 as Element of G;
    a" is Element of A & g2 is Element of G; then
    B2: <* a", g2 *> is Element of semidirect_product (A,G,phi)
    by th3; then
    reconsider g = <* a", g2 *> as Element of semidirect_product (A,G,phi)
    by th3;
    take g;
    thus h * g = e & g * h = e by A1,B1,B2,th11;
  end;
  hence thesis by A2;
end;

theorem th13:
  for x, y, z being Element of semidirect_product (A, G, phi)
  holds (x * y) * z = x * (y * z)
proof
  let x, y, z be Element of semidirect_product (A, G, phi);
  consider a1 being Element of A, g1 being Element of G such that
  A1: x = <* a1, g1 *>
  by th5;
  consider a2 being Element of A, g2 being Element of G such that
  A2: y = <* a2, g2 *>
  by th5;
  consider a3 being Element of A, g3 being Element of G such that
  A3: z = <* a3, g3 *>
  by th5;

  A4: x * y = <* a1 * a2, g1 * ((phi /. a1)/.g2) *> by A1,A2,th6;
  then A5: (x * y) * z = <* (a1 * a2) * a3, (g1 * ((phi /.a1)/.g2)) *
  ((phi /. (a1 * a2)) /. g3)*> by A3,A4,th6;

  y * z = <* a2 * a3, g2 * ((phi /. a2)/.g3) *> by A2,A3,th6;
  then A6: x * (y * z) = <* a1 * (a2 * a3), g1 * ((phi /. a1)/.(g2 * ((phi /. a2)/.g3))) *>
  by A1,th6;

  A7: (a1 * a2) * a3 = a1 * (a2 * a3) by GROUP_1:def 3;

  ((phi /. a1) . ((phi /. a2).g3)) = (phi /. (a1 * a2)) . g3 by th9;
  then 
  ((phi /. a1).(g2 * ((phi /. a2)/.g3)))
  = ((phi /. a1).g2) * ((phi /. (a1 * a2)) . g3) by th9,GROUP_6:def 6;
  then (((phi /.a1)/.g2) * ((phi /. (a1 * a2)) /. g3))
  = ((phi /. a1)/.(g2 * ((phi /. a2)/.g3)));
  then 
  (g1 * ((phi /.a1)/.g2)) * ((phi /. (a1 * a2)) /. g3)
  = g1 * ((phi /. a1)/.(g2 * ((phi /. a2)/.g3))) by GROUP_1:def 3,GROUP_6:def 6;
  hence thesis by A5,A6,A7,Lm1;
end;

registration
  let G be strict Group;
  let A be Group;
  let phi be Homomorphism of A, AutGroup G;
  cluster semidirect_product (A, G, phi) -> associative;
  correctness by th13, GROUP_1:def 3;
  cluster semidirect_product (A, G, phi) -> Group-like;
  correctness by th12, GROUP_1:def 2;
end;

LmDoubleCheckSemidirectProductIsGroup:
  semidirect_product (A, G, phi) is Group;

theorem th14:
  1_(semidirect_product (A, G, phi)) = <* 1_A, 1_G *>
proof
  reconsider e = <* 1_A, 1_G *> as Element of semidirect_product (A, G, phi)
  by th3;
  A1: e = <* 1_A, 1_G *>;
  for x being Element of semidirect_product (A, G, phi)
  holds x * e = x & e * x = x by th8;
  hence thesis by A1, th8, th12, GROUP_1:def 4;
end;

theorem th15:
  for a being Element of A
  for g being Element of G
  for x being Element of semidirect_product (A, G, phi)
  st x = <* a, g *>
  holds x" = <* a", (phi/.(a"))/.(g") *>
proof
  let a be Element of A;
  let g be Element of G;
  let x be Element of semidirect_product (A, G, phi);
  assume A1: x = <* a, g *>;
  reconsider e = <* 1_A, 1_G *> as Element of semidirect_product (A, G, phi)
  by th3;
  A2: e = <* 1_A, 1_G *>;
  reconsider y = <* a", (phi/.(a"))/.(g") *> as Element of semidirect_product (A, G, phi)
  by th3;
  A3: y = <* a", (phi/.(a"))/.(g") *>; then
  x * y = e & y * x = e by A1,A2,th11; then
  x * y = 1_(semidirect_product(A, G, phi))
  & y * x = 1_(semidirect_product(A, G, phi)) by th14; then
  y = x" by GROUP_1:def 5;
  hence x" = <* a", (phi/.(a"))/.(g") *> by A3;
end;

theorem
  ex N being normal Subgroup of semidirect_product (A, G, phi)
  st N, A are_isomorphic;
::>                    *4

theorem
  semidirect_product (A, G, 1:(A, AutGroup G)) = product <*A, G*>
proof
  set S = semidirect_product (A, G, 1:(A, AutGroup G));
  A1: the carrier of S = the carrier of product <*A,G*> by th2;
  set B1 = the multF of S;
  set B2 = the multF of product <*A, G*>;
  set U = product (Carrier <*A,G*>);
  the carrier of S = product (Carrier<*A,G*>) &
  B1 is BinOp of the carrier of S by Def1;
  then A2: B1 is BinOp of U;
  the carrier of product <*A,G*> = product (Carrier <*A,G*>) &
  the multF of product <*A,G*> is BinOp of the carrier of product <*A,G*> by GROUP_7:def 2;
  then A3: B2 is BinOp of U;

  for x,y being Element of product (Carrier <*A,G*>)
  holds B1.(x,y) = B2.(x,y)
  proof
    let x,y be Element of product (Carrier <*A,G*>);
    x is Element of S by Def1;
    then consider a1 being Element of A, g1 being Element of G such that
    A4: x = <*a1,g1*> by th5;
    y is Element of S by Def1;
    then consider a2 being Element of A, g2 being Element of G such that
    A5: y = <*a2,g2*> by th5;
    1:(A, AutGroup G) = A --> (1_(AutGroup G)) by GROUP_6:def 7; then
    (1:(A, AutGroup G)).a1 = 1_(AutGroup G) by FUNCOP_1:7
                          .= id the carrier of G by AUTGROUP:9; then
    ((1:(A, AutGroup G)) . a1) . g2 = g2;
    then A6: (((1:(A, AutGroup G)) /. a1) /. g2) = g2;
    reconsider x0=x,y0=y as Element of S by Def1;
    x0 = <*a1,g1*> & y0 = <*a2,g2*> by A4,A5;
    then A7: x0 * y0 = <* a1 * a2, g1 * (((1:(A, AutGroup G)) /. a1)/.g2) *> by th6
                    .= <* a1 * a2, g1 * g2 *> by A6;
    A8: B1.(x,y) = B1.(x0, y0)
                .= <* a1 * a2, g1 * g2 *> by A7;

    B2.(x,y) = B2.(<*a1,g1*>, <*a2,g2*>) by A4,A5
            .= <*a1,g1*> * <*a2,g2*>
            .= <* a1 * a2, g1 * g2 *> by A4,A5,GROUP_7:29;
    hence B1.(x,y) = B2.(x,y) by A8;
  end;
  then B1 = B2 by A1,A2,A3,BINOP_1:2;
  hence thesis by A1;
end;

:: for alpha being Homomorphism of A,B st alpha is bijective
:: for beta being Automorphism of A
:: holds alpha * beta * alpha" is Automorphism of B;


:: for alpha being Homomorphism of A,B st alpha is bijective
:: ex alpha_star being Homomorphism of AutGroup A, AutGroup B
:: st for beta being Automorphism of A holds alpha_star.beta = alpha * beta * alpha";

:: Aschbacher, Finite Group Theory, section 4 (page 9)
:: This is a highly idiosyncratic notion, which I haven't seen outside
:: Aschbacher's book.
definition
  let A1,A2 be Group;
  let G1,G2 be strict Group;
  let pi1 be Homomorphism of A1,AutGroup G1;
  let pi2 be Homomorphism of A2,AutGroup G2;
  pred pi1,pi2 are_quasi-equivalent means :Def2:
  ex beta being Homomorphism of G2,G1,
     alpha being Homomorphism of A1,A2
  st alpha is bijective & beta is bijective &
     for a being Element of A2
     for f being Homomorphism of G1,G2
     st f = (pi1 * beta).a
     holds pi2.a = alpha * f * alpha";
end;

begin :: Central Subgroups and Central Products

definition
  let A;
  let IT be Subgroup of A;
  attr IT is central means :Def3:
  for g,h being Element of A st h in IT holds g*h = h*g;
end;

theorem th22:
  center A is central by Def3,GROUP_5:77;

registration
  let A;
  cluster central for Subgroup of A;
  existence
  proof
    take center A;
    thus thesis by th22;
  end;
end;

registration
  let A;
  cluster center A -> central;
  correctness by th22;
end;

:: GROUP_3:58?
theorem th23:
  for S being central Subgroup of A
  holds S is normal
proof
  let S be central Subgroup of A;
  for a being Element of A holds S |^ a = S;
::>                                *165,203
  hence S is normal by GROUP_3:118;
end;


registration
  let A;
  cluster central -> normal for Subgroup of A;
  correctness by th23;
end;




::> 4: This inference is not accepted
::> 165: Unknown functor format
::> 203: Unknown token, maybe an illegal character used in an identifier
